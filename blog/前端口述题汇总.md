### vue router 实现原理
- 因为是插件所以要实现 install 方法挂载到 vue 原型上
- install 方法将来会被 Vue.use 调用
- link 组件根据组件传入的值渲染
- view 组件响应式渲染当前路由对应的组件
- [https://github.com/taowuu/tao-mini-router](https://github.com/taowuu/tao-mini-router)

### vuex 实现原理
- 因为是插件所以要实现 install 方法挂载到 vue 原型上
- install 方法将来会被 Vue.use 调用
- 响应化中心数据
- 实现 commit 根据 type 执行 mutation
- 实现 dispatch 根据 type 执行 action
- action 保存对应 commit 函数
- mutation 修改 store
- getters 从 store 派生出新状态
- [https://github.com/taowuu/tao-mini-vuex](https://github.com/taowuu/tao-mini-vuex)

### vue 实现原理
- 模板编译 - 绑定更新函数 - 初始化视图<br />
- 数据响应化 - 收集依赖<br />
- 数据响应化 - 数据变化 - 执行更新函数
- observer 响应化数据
- compile 模板编译
- watcher 保存更新函数
- dep 管理 watcher
- [https://github.com/taowuu/tao-mini-vue](https://github.com/taowuu/tao-mini-vue)

### vue 组件通信方式
- 父组件注入数据子组件通过 props 接收，子组件 emit 数据父组件通过 @ 监听
- 创建 eventHub，兄组件向 eventHub emit 发送数据，弟组件 on eventHub 监听获取数据

### SPA 原理
- 切换页面的同时修改路由但不刷新页面<br />
- 访问路由时能够渲染出对应页面
#### history 模式
```js
var state = {
    page: "settings"
}
// pushState 增加一条历史记录
history.pushState(state, "settings", "/settings")
// 用户点击 前进 后退 按钮的时候, 会触发 window 的 popstate 事件
window.addEventListener("popstate", function(e) {
    var state = e.state
    // state 就是 pushState 的第一个参数
    // 根据 state 渲染对应组件
    console.log('pop state', state)
})
```
#### hash 模式
```js
window.onhashchange = (e) => {
    // 监听 hash 改变渲染对应组件
    console.log(e.newUrl)
    console.log(location.hash)
}
// 增加历史记录
el.addEventListener('click', () => {
    location.href = '#/user'
})
```

### 虚拟 DOM diff 算法
- 如果新节点的标签和 key 与老节点不相同：
    - 创建新节点并插入容器，删除老节点
- 如果新节点的标签和 key 与老节点相同：
    - 如果新老节点相同不做操作
    - 如果新节点无 text 有 children：
        - 老节点有 children 走 update children
        - 老节点有 text 则清空，添加上新节点的 children
    - 如果新节点有 text 无 children：
        - 老节点有 text 清空更新为新 text
        - 老节点有 children 移除并更新为新节点的 text 

### 浏览器的渲染流程
1. 浏览器使用 http 协议请求域名路径对应的页面
2. dns 解析域名得到 ip 定位到服务器
3. 把请求回来的 html 解析成 dom 树
4. 计算 dom 树的 css 属性
5. 根据 css 属性对元素进行渲染得到内存中的位图
6. 对位图进行合成
7. 绘制到界面

### 浏览器的本地存储
#### LocalStorage
- 没有过期时间
- 持久化在本地的一个存储空间
- 域名相同的页面才能相互读取
- 每个域名最大存储量为 5MB
- 与 HTTP 无关
- 用于记录有无提示过用户等
#### SessionStorage
- 页面关闭则过期
- 持久化在本地的一个存储空间
- 域名相同的页面才能相互读取
- 每个域名最大存储量为 5MB
- 与 HTTP 无关
- 用于一次性敏感信息等
#### Cookie
- 登录成功后服务器给浏览器发送的随机字符串
- 浏览器会在每次请求服务器时自动带上这个字符串
- 每个域名最大存储量为 4KB

### webapck plugin 实现原理
- plugin 是个类，在 apply 钩子中编写逻辑
- 在 plugins 数组中 new 后使用

### webapck loader 实现原理
- loader 是个函数，最终导出为字符串形式的函数
- 在 module.rules 数组中根据文件类型使用

### 如何理解 HTML 中的语义化标签?
HTML中的语义化标签是指使用恰当的标签来表示页面的结构和内容，而不是仅仅用于展示样式。语义化标签可以让页面更容易被浏览器、搜索引擎和其他设备解析，从而提高可访问性、可维护性和SEO效果

### HTML5 有哪些新标签?
- 语义/结构标签：这些标签用来定义页面的不同部分，如header、nav、main、article、section、aside、footer
- 表单标签：这些标签用来定义表单的输入控件和输出结果，如datalist、keygen、output
- 输入类型：这些类型用来定义表单输入域的不同格式，如color、date、email、number、range
- 输入属性：这些属性用来定义表单输入域的不同特性，如autocomplete、autofocus、formaction、pattern
- 图像标签：这些标签用来定义使用JavaScript或SVG绘制的图像，如canvas、svg
- 媒体标签：这些标签用来定义音频或视频内容，以及它们的来源和轨道，如audio、video、source、track

### Canvas 和 SVG 的区别是什么?
- Canvas 是基于像素的位图，而 SVG 是基于矢量的图形。这意味着 Canvas 的图形会随着分辨率的变化而失真，而 SVG 的图形可以无限放大而不失真
- Canvas 是使用 JavaScript 程序绘制的，而 SVG 是使用 XML 文档描述的。这意味着 Canvas 的图形更灵活，可以实现动画、交互等效果，而 SVG 的图形更易于编辑、保存和复用
- Canvas 不支持事件处理器，而 SVG 支持事件处理器。这意味着 Canvas 的图形不能响应用户的操作，而 SVG 的图形可以添加点击、鼠标移动等事件

### meta viewport 是做什么用的？
meta viewport 是一种用于控制页面在不同设备上的显示和缩放的方法12。它是一种 HTML5 提供的 <meta> 标签，可以用来定义视口（viewport）的大小和形状

### BFC 是什么?
BFC 是一个独立的渲染区域，它规定了内部的块级盒子如何布局与这个区域外部毫不相干，用于防止 margin 重叠、清除浮动等

### 如何实现垂直居中?
- 使用position和transform实现垂直居中：适合任意元素，将元素设为绝对定位，然后使用top:50%和transform:translateY(-50%)即可
- 使用flex实现垂直居中：适合任意元素，将父元素设为display:flex，然后使用align-items:center或align-self:center即可。

### CSS 选择器优先级如何确定?
- 内联样式 > ID 选择器 > 类选择器 = 属性选择器 = 伪类选择器 > 标签选择器 = 伪元素选择器 > 通配符选择器
- 如果两个或多个选择器的类型数值相同，则比较每种类型的选择器的个数，按照 ID 选择器 > 类选择器 = 属性选择器 = 伪类选择器 > 标签选择器 = 伪元素选择器 的顺序依次比较，大的则优先级高，相等则比较下一个
- 如果两个或多个选择器的类型数值和个数都相同，则按照在 CSS 文件中出现的顺序，后出现的优先级高
- 如果两个或多个选择器的类型数值和个数都相同，则按照在 CSS 文件中出现的顺序，后出现的优先级高
- 如果一个声明中使用了 !important 规则，则该声明的优先级最高，除非有其他声明也使用了 !important 规则且具有更高或相同的优先级
- 继承得到的样式的优先级最低，除非有其他声明使用了 !important 规则

### 如何清除浮动?
- 使用 overflow 属性：给浮动元素的父元素设置 overflow: hidden; 或者 overflow: auto; 属性，可以触发父元素的 BFC (块级格式化上下文)，使父元素能够包含浮动元素，从而清除浮动。这种方法不需要增加额外的标签，但是会影响元素的显示效果，比如隐藏溢出的内容或者出现滚动条。
- 使用伪元素 :after：给浮动元素的父元素添加一个类名，例如 clearfix ，然后使用伪元素 :after 在父元素内部的最后生成一个看不见的块级元素 content: "";，并给它设置 clear: both; 属性，实现清除浮动的效果。这种方法也不需要增加额外的标签，而且兼容性较好，是比较推荐的一种方法。

### 两种盒模型(box-sizing)的区别?
- content-box: width === content
- border-box: width === content + padding + border

### css.reset 和 normalize.css 有什么区别？
- reset 抛弃默认样式
- normalize 统一各浏览器上的标签默认样式

### JS 的数据类型有哪些?
- 值类型 (基本类型)：字符串（String）、数字 (Number)、布尔 (Boolean)、空（Null）、未定义（Undefined）、Symbol。
- 引用数据类型：对象 (Object)、数组 (Array)、函数 (Function)。

### 原型链是什么?
- 每个对象都有一个内部属性 [[Prototype]] ，也可以通过 proto 属性来访问，它指向该对象的原型对象。
每个函数都有一个 prototype 属性，它指向该函数的原型对象，该原型对象有一个 constructor 属性，指回该函数本身。
- 当创建一个对象时，可以指定它的原型对象，例如通过字面量、构造函数或者 Object.create() 方法。
- 当访问一个对象的属性时，会先在该对象自身查找，如果找不到，则会沿着 [[Prototype]] 链向上查找，直到找到或者到达 Object.prototype ，它是所有对象的最终原型。如果仍然找不到，则返回 undefined 。
- 当设置一个对象的属性时，会先检查该属性是否是只读的，如果是，则抛出 TypeError 异常。如果不是，则会在该对象自身添加或修改该属性，不会影响原型链上的任何对象。

### JS 的 new 做了什么?
- 创建一个空对象，并将 this 指向该对象。
- 将该对象的原型链指向构造函数的 prototype 属性，继承构造函数的属性和方法。
- 执行构造函数中的代码，给该对象添加自身的属性和方法。
- 如果构造函数有返回值，则返回该值，否则返回创建的对象。

### JS 的立即执行函数是什么?
- 使用圆括号包裹一个匿名函数，并在后面加上一对圆括号表示调用，例如：(function() { ... })() 。
- 使用圆括号包裹一个箭头函数，并在后面加上一对圆括号表示调用，例如：(() => { ... })() 。
- 创建一个独立的作用域，避免变量污染全局作用域，保护变量的私有性。
- 封装一些只需要执行一次的初始化代码，不需要重复调用。
- 实现模块模式，通过返回一个对象来暴露公有的属性和方法，隐藏私有的细节。
- 为了兼容 ES6 之前没有块级作用域的问题，使用 IIFE 来模拟块级作用域。

### JS 的闭包是什么?怎么用?
- 闭包是指一个函数以及其捆绑的周边环境状态（词法环境）的引用的组合
- 实现私有变量和私有方法，通过返回一个对象来暴露公有的属性和方法，隐藏私有的细节。
- 实现模拟类和继承，通过使用构造函数和原型链来创建类和子类，实现面向对象编程的特性。
- 实现柯里化和偏函数，通过预设一些参数来创建一个新的函数，实现参数复用和动态生成函数的功能。
- 实现记忆化，通过缓存计算结果来提高性能，避免重复计算相同的输入。

### JS 如何实现类?
- 使用原型（prototype）机制，把不可共享的属性放在构造函数里，把共享的属性和方法写在原型对象上
- 使用 ES6 的 class 关键字，把本身的属性写在 constructor 里，把共享的属性和方法写在 constructor 外

### JS 如何实现继承?
- 使用原型链，让子类的原型对象指向父类的原型对象，从而继承父类的属性和方法
- 使用 ES6 的 class 和 extends 关键字，让子类继承父类的构造函数和原型方法
- 使用工厂模式，创建一个工厂函数，根据不同的参数返回不同的对象，实现继承和多态⁴。例如：

### JS 垃圾回收是什么?
- JS 垃圾回收是一种内存管理机制，它可以自动释放不再使用的对象所占用的内存空间
- 从根对象（全局对象）开始，遍历所有从根对象可达的对象，标记它们为活动对象。
- 对于那些从根对象不可达的对象，判断它们是否可以被回收。如果一个对象没有其他对象引用它，或者存在循环引用的情况，那么它就是不可达的，可以被回收。
- 回收不可达的对象所占用的内存空间，释放给操作系统或者其他程序使用。
- 引用计数：每个对象维护一个引用计数器，记录有多少个对象引用它。当引用计数器变为零时，该对象就可以被回收。这种算法的缺点是无法处理循环引用的情况
- 标记清除：从根对象开始，遍历所有可达的对象，并标记它们。然后清除所有未被标记的对象。这种算法可以解决循环引用的问题，但是会产生内存碎片
- 标记整理：在标记清除的基础上，将所有活动对象移动到一端，然后清除另一端的空闲内存。这种算法可以避免内存碎片，但是会增加移动对象的开销
- 分代回收：根据对象的存活时间，将内存分为新生代和老生代两部分。新生代中的对象存活时间短，使用复制算法进行回收；老生代中的对象存活时间长，使用标记清除或标记整理进行回收

### 请简述 DOM 事件模型
- DOM 事件模型是指 DOM 中的事件如何在文档元素中传播和处理的机制
- 事件流：事件流描述了事件在 DOM 树中的传播顺序，分为捕获阶段、目标阶段和冒泡阶段。捕获阶段是从根节点到目标节点的过程，冒泡阶段是从目标节点到根节点的过程，目标阶段是在目标节点上触发事件的过程
- 事件模型：事件模型指的是浏览器如何支持事件监听和触发的方式，分为传统模型和标准模型。传统模型只支持冒泡阶段的事件监听，使用 on+event 的属性或者 attachEvent 方法来绑定事件处理函数；标准模型支持捕获和冒泡两个阶段的事件监听，使用 addEventListener 方法来绑定事件处理函数，并通过第三个参数来指定监听的阶段
- 事件对象：事件对象是一个包含了与事件相关的信息和方法的对象，它会作为参数传递给事件处理函数。事件对象有一些通用的属性和方法，如 type、target、stopPropagation 等，也有一些特定于不同类型的事件的属性和方法，如 keyCode、clientX
- 事件委托：事件委托是一种利用事件冒泡机制，将子元素的事件监听委托给父元素或祖先元素的技巧。它可以避免对每个子元素都绑定事件处理函数，提高性能和灵活性

### GET 和 POST 的区别有哪些?
- GET 用于从服务器获取数据，POST 用于向服务器提交数据。
- GET 把参数拼接在 URL 中，POST 把参数放在请求体中。
- GET 请求的 URL 有长度限制，POST 请求没有。
- GET 请求的参数只能是 ASCII 字符，POST 请求可以支持多种编码和数据类型。
- GET 请求可以被缓存、收藏和浏览器历史记录，POST 请求不可以。
- GET 请求相对不安全，因为参数暴露在 URL 中，POST 请求相对安全，因为参数不会显示在 URL 中。

### HTTP 缓存有哪些方案?
你好，这是 Bing。😊

HTTP 缓存是一种提高网页性能的技术，它可以减少网络请求的次数和数据量，从而提高网页的加载速度和用户体验。HTTP 缓存有以下几种方案¹²：

- 强缓存：强缓存是利用响应头中的 Expires 或 Cache-Control 字段来控制的，它们指定了资源的过期时间，如果没有过期，浏览器就可以直接从本地缓存中读取资源，不需要再向服务器发起请求。
- 协商缓存：协商缓存是利用请求头中的 If-Modified-Since 或 If-None-Match 字段和响应头中的 Last-Modified 或 ETag 字段来控制的，它们用于判断资源是否在服务器端发生了变化，如果没有变化，服务器就会返回 304 Not Modified 状态码，告诉浏览器可以继续使用本地缓存的资源，如果有变化，服务器就会返回 200 OK 状态码和新的资源。
- Service Worker 缓存：Service Worker 是一种运行在浏览器后台的脚本，它可以拦截和处理网络请求，实现离线缓存、消息推送等功能。Service Worker 缓存是利用 Cache API 来控制的，它可以自定义缓存策略，如缓存优先、网络优先、同时请求缓存和网络等。
- Push Cache：Push Cache 是 HTTP/2 中的一种缓存机制，它允许服务器主动推送资源给客户端，而不需要客户端发起请求。Push Cache 的生命周期很短，只在一次会话（session）中有效，一旦会话结束就被释放。

### HTTP 和 HTTPS 的区别有哪些?
- HTTP 是超文本传输协议，它是一种明文的协议，它的数据传输是不安全的，容易被窃听、篡改和伪造。
- HTTPS 是安全套接字层超文本传输协议，它是一种在 HTTP 的基础上加入了 SSL/TLS 协议的协议，它的数据传输是加密的 它可以保证数据的安全性、完整性和身份认证。
- HTTP 和 HTTPS 使用不同的端口，HTTP 默认使用 80 端口，HTTPS 默认使用 443 端口。
- HTTP 和 HTTPS 在 URL 的格式上也有区别，HTTP 的 URL 以 http:// 开头，HTTPS 的 URL 以 https:// 开头。
- HTTP 和 HTTPS 对搜索排名也有影响，搜索引擎会优先收录 HTTPS 的网站，并给予更高的权重。

### HTTP/1.1 和 HTTP/2 的区别有哪些?
- HTTP/1.1 是基于文本的协议，它的报文格式是由换行符分隔的纯文本，容易阅读和调试，但也存在冗余和解析困难的问题。
- HTTP/2 是基于二进制的协议，它的报文格式是由帧组成的二进制数据流，更紧凑和高效，但也更难理解和处理。
- HTTP/1.1 是基于请求-响应模式的协议，它的连接是有序的，每个请求和响应都要按照顺序进行，如果某个请求或响应耗时过长，就会阻塞后续的请求或响应，导致性能下降。
- HTTP/2 是基于消息-流模式的协议，它的连接是多路复用的，可以同时发送和接收多个请求和响应，而不需要等待前一个请求或响应完成，避免了队头阻塞的问题。
- HTTP/1.1 的头部信息是明文的，没有进行压缩，导致网络开销较大，尤其是当头部信息包含大量重复内容时。
- HTTP/2 的头部信息是经过 HPACK 算法压缩后的二进制数据，减少了传输的大小和次数，提高了效率。
- HTTP/1.1 的连接是短暂的，每次请求或响应完成后都会关闭连接，下次请求或响应需要重新建立连接，增加了延迟和消耗。
- HTTP/2 的连接是持久的，一旦建立连接就会保持打开状态，直到客户端或服务器主动关闭，减少了建立连接的开销。
- HTTP/1.1 不支持服务器推送功能，即服务器只能被动地响应客户端的请求，不能主动地向客户端推送资源。
- HTTP/2 支持服务器推送功能，即服务器可以在客户端请求之前主动地向客户端发送资源，提高了用户体验。

### TCP 三次握手和四次挥手是什么?
- TCP 三次握手的过程如下：
    - 客户端向服务器发送一个 SYN 报文，表示请求建立连接，同时发送一个初始序列号 x；
    - 服务器收到 SYN 报文后，如果同意建立连接，就向客户端发送一个 SYN+ACK 报文，表示确认客户端的请求，同时发送一个初始序列号 y 和一个确认号 x+1；
    - 客户端收到 SYN+ACK 报文后，向服务器发送一个 ACK 报文，表示确认服务器的响应，同时发送一个确认号 y+1；
- TCP 四次挥手的过程如下：
    - 客户端向服务器发送一个 FIN 报文，表示请求断开连接；
    - 服务器收到 FIN 报文后，向客户端发送一个 ACK 报文，表示确认客户端的请求；
    - 服务器等待所有数据传输完毕后，向客户端发送一个 FIN 报文，表示请求断开连接；
    - 客户端收到 FIN 报文后，向服务器发送一个 ACK 报文，表示确认服务器的请求；

### 说说同源策略和跨域
- 同源策略是浏览器的一种安全策略，它限制了不同源的文档或脚本之间的交互，以防止恶意攻击
- 同源策略的判断标准是：协议、域名和端口号必须完全相同，否则就是不同源
- 跨域是指不同源的文档或脚本之间的通信，由于同源策略的限制，跨域需要特殊的处理方法，否则会被浏览器拒绝或报错
- 跨域的常见场景有：CDN、第三方登录、跨域 AJAX、IFrame 和跨域资源嵌入等
- 跨域的常见解决方法有：JSONP、CORS、代理服务器、Websocket、PostMessage 等

### JSONP 是什么
- JSONP 是一种利用 <script> 标签的 src 属性没有跨域限制的特点，通过动态创建 <script> 标签，向服务器发送请求，并通过回调函数接收响应数据的技术
- JSONP 的优点是简单易用，兼容性好，缺点是只能发送 GET 请求，不安全，不容易出错处理
- JSONP 的使用方法如下：
    - 客户端定义一个回调函数，并将函数名作为参数传递给服务器；
    - 服务器根据客户端传递的参数和数据，构造一个 JSONP 格式的响应，即用回调函数名包裹 JSON 数据；
    - 客户端通过 <script> 标签动态加载服务器返回的响应，并执行回调函数；

### CORS 是什么
- CORS 是一种基于 HTTP 头部的机制，它允许服务器声明哪些源可以访问哪些资源，并允许浏览器向跨源服务器发送 XMLHttpRequest 请求
- CORS 的优点是支持各种类型的请求，安全可靠，容易实现，缺点是需要浏览器和服务器同时支持，老版本浏览器不兼容
- CORS 的使用方法如下：
    - 对于简单请求（GET、HEAD、POST），浏览器会在请求头中添加 Origin 字段，表示请求来源；
    - 服务器根据 Origin 字段判断是否允许跨域，并在响应头中添加 Access-Control-Allow-Origin 字段，表示允许访问的源；
    - 浏览器根据 Access-Control-Allow-Origin 字段判断是否接收响应数据；
    - 对于非简单请求（PUT、DELETE、PATCH 等），浏览器会先发送一个预检请求（OPTIONS），询问服务器是否允许跨域，并携带相关信息（如请求方法、自定义头部等）；
    - 服务器根据预检请求中携带的信息判断是否允许跨域，并在响应头中添加

### TS 和 JS 的区别是什么?有什么优势?
- TS 是 JS 的一个超集，它在 JS 的基础上增加了一些新的特性，如静态类型、类、接口、泛型、装饰器等
- TS 需要编译成 JS 才能在浏览器或 Node.js 中运行，而 JS 可以直接运行
- TS 提供了更强的类型检查和错误提示，可以在编译阶段发现和避免潜在的错误，而 JS 是动态类型的，只能在运行时检查错误
- TS 支持最新的 ECMAScript 标准和提案，可以使用更多的语法特性和 API，而 JS 可能需要借助 Babel 等工具进行转换
- TS 可以提高代码的可读性、可维护性和可靠性，有利于大型项目的开发和团队协作
- TS 可以利用智能提示、重构、导航等 IDE 功能，提高开发效率和代码质量
- TS 可以兼容 JS 的语法和库，拥有庞大的社区和生态系统

### any、unknown、never的区别是什么?
- any 表示任意类型，它可以赋值给任何变量，也可以接受任何变量的赋值，它不会进行类型检查，也不会受到类型约束。
- unknown 表示未知类型，它只能赋值给 any 和 unknown 类型的变量，也只能接受 any 和 unknown 类型的变量的赋值，它会进行类型检查，需要进行类型断言或类型守卫才能访问其属性或方法。
- never 表示永远不存在的类型，它不能赋值给任何变量，也不能接受任何变量的赋值，它通常用于表示抛出异常或无限循环的函数的返回值。

### type 和 interface 的区别是什么?
- type 可以定义基本类型、联合类型、元组类型、函数类型等，而 interface 只能定义对象类型或函数类型。
- type 可以使用 typeof 操作符获取一个变量的类型，而 interface 不能。
- type 不能被重复定义或扩展，而 interface 可以被重复定义或扩展。
- type 和 interface 都可以实现泛型和继承，但是 type 可以使用交叉类型（&）进行组合，而 interface 可以使用逗号（,）进行多继承。

### TS工具类型Partial、Required、Readonly、 Exclude、Extract、Omit、ReturnType的作用

Partial<T> 的作用是将类型 T 的所有属性变为可选的，例如：

```typescript
interface User {
  name: string;
  age: number;
}

type PartialUser = Partial<User>; // { name?: string; age?: number }
```

Required<T> 的作用是将类型 T 的所有属性变为必选的，例如：

```typescript
interface User {
  name?: string;
  age?: number;
}

type RequiredUser = Required<User>; // { name: string; age: number }
```

Readonly<T> 的作用是将类型 T 的所有属性变为只读的，例如：

```typescript
interface User {
  name: string;
  age: number;
}

type ReadonlyUser = Readonly<User>; // { readonly name: string; readonly age: number }
```

Exclude<T, U> 的作用是从类型 T 中排除可以赋值给 U 的那些类型，例如：

```typescript
type A = string | number | boolean;

type B = Exclude<A, string>; // number | boolean
```

Extract<T, U> 的作用是从类型 T 中提取可以赋值给 U 的那些类型，例如：

```typescript
type A = string | number | boolean;

type B = Extract<A, string>; // string
```

Omit<T, K> 的作用是从类型 T 中剔除指定的属性 K，例如：

```typescript
interface User {
  name: string;
  age: number;
}

type OmitUser = Omit<User, "age">; // { name: string }
```

ReturnType<T> 的作用是获取函数类型 T 的返回值类型，例如：

```typescript
function add(x: number, y: number): number {
  return x + y;
}

type Result = ReturnType<typeof add>; // number
```

### Vue2 的生命周期钩子有哪些?数据请求放在哪 个钩子?
- beforeCreate：在实例创建之前调用，此时 data、methods、computed 等选项还没有初始化。
- created：在实例创建之后调用，此时 data、methods、computed 等选项已经初始化，但是还没有挂载 DOM。
- beforeMount：在实例挂载之前调用，此时 template 或 render 函数已经编译成渲染函数，但是还没有执行。
- mounted：在实例挂载之后调用，此时渲染函数已经执行，DOM 已经更新。
- beforeUpdate：在实例更新之前调用，此时响应式数据已经更新，但是还没有更新 DOM。
- updated：在实例更新之后调用，此时响应式数据和 DOM 都已经更新。
- beforeDestroy：在实例销毁之前调用，此时实例仍然可用，但是即将被销毁。
- destroyed：在实例销毁之后调用，此时实例已经不可用，所有的数据和事件监听器都被移除。

数据请求一般放在 created 或 mounted 钩子中，具体取决于数据请求的时机和依赖。如果数据请求不依赖于 DOM 元素或其他组件的状态，可以放在 created 钩子中，以提高性能。如果数据请求依赖于 DOM 元素或其他组件的状态，可以放在 mounted 钩子中，以保证正确性。

### Vue2 组件间通信方式有哪些?
- props 和 $emit：父组件通过 props 向子组件传递数据，子组件通过 $emit 向父组件触发事件并传递数据，实现父子组件间的通信。
- $attrs 和 $listeners：当子组件没有声明 props 时，父组件传递的属性会被收集到 $attrs 中，子组件可以通过 $attrs 访问这些属性；父组件传递的事件监听器会被收集到 $listeners 中，子组件可以通过 $listeners 访问这些事件监听器，实现非父子组件间的通信。
- provide 和 inject：祖先组件通过 provide 提供数据或方法，后代组件通过 inject 接收数据或方法，实现祖先后代组件间的通信。
- $parent 和 $children：子组件可以通过 $parent 访问父组件的实例，父组件可以通过 $children 访问子组件的实例，实现父子组件间的通信。
- $root 和 $refs：任意组件可以通过 $root 访问根组件的实例，根组件可以通过 $refs 访问任意组件的实例，实现任意组件间的通信。
- event bus：创建一个空的 Vue 实例作为事件总线，任意组件可以通过它来触发或监听事件，实现任意组件间的通信。
- Vuex：创建一个全局的状态管理对象，任意组件可以通过它来存取或修改状态，实现任意组件间的通信。

### Vuex 用过吗?怎么理解?
Vuex 是一个专为 Vue 应用程序开发的状态管理模式，它可以集中管理应用程序中的所有组件的状态，实现数据的统一管理和更新。

Vuex 的核心概念有以下几个：

- state：存储应用程序的状态数据，相当于一个全局的 data 对象，任何组件都可以访问或修改它。
- getters：对 state 中的数据进行计算或过滤，相当于一个全局的 computed 对象，任何组件都可以访问它。
- mutations：定义修改 state 中数据的同步方法，相当于一个全局的 methods 对象，只能通过 commit 方法触发它。
- actions：定义修改 state 中数据的异步方法，相当于一个全局的 methods 对象，可以包含任意异步操作，只能通过 dispatch 方法触发它。
- modules：将 state、getters、mutations、actions 分割到不同的模块中，实现状态数据的模块化管理。

### VueRouter 用过吗?怎么理解?
VueRouter 是一个专为 Vue 应用程序开发的路由管理器，它可以实现单页面应用程序中的页面切换和导航功能。

VueRouter 的核心概念有以下几个：

- 路由：定义了不同的 URL 对应不同的组件，可以是静态的或动态的，可以嵌套或命名，可以配置元数据或过渡效果。
- 路由器：创建并管理路由的实例，可以配置路由模式（hash 或 history）、路由匹配规则、路由守卫等。
- 路由视图：在页面中渲染匹配到的路由组件的占位符，可以是单个的或多个的，可以嵌套或命名。
- 导航：在页面中提供跳转到不同路由的链接，可以是声明式的（<router-link>）或编程式的（router.push）。

### 如何用路由守卫实现权限控制和加载进度?
- 可以使用 Vue-Router 中的 **beforeEach** 和 **afterEach** 钩子函数来实现这个功能。

- **beforeEach** 钩子函数在路由跳转前触发，你可以在这里判断用户的登录状态和路由权限，如果不满足条件，你可以使用 **next** 函数来中断或重定向路由跳转。

- **afterEach** 钩子函数在路由跳转后触发，你可以在这里关闭进度条或做其他操作。

### Vue2 是如何实现双向绑定的?
- Vue2 实现双向绑定的原理是通过 **数据劫持** 结合 **发布订阅模式** 的方式来实现的。也就是说，Vue2 通过 **Object.defineProperty()** 方法来劫持各个属性的 **setter** 和 **getter**，在数据变动时发布消息给订阅者，触发相应的监听回调。

- Vue2 提供了 **v-model** 指令来实现表单元素和数据的双向绑定，它其实是一个语法糖，相当于绑定了 **value** 属性和 **input** 事件。你可以在组件中使用 **model** 选项来自定义 **v-model** 的属性和事件。

- Vue2 还提供了 **.sync** 修饰符来实现父子组件之间的双向绑定，它其实是一个语法糖，相当于在子组件中触发一个 **update:propName** 的事件来更新父组件的属性。

### Vue3 为什么使用 Proxy?
- Proxy 是一个新的 JavaScript 语言特性，它可以在目标对象之前架设一层“拦截”，对外界的访问进行过滤和改写。Proxy 可以拦截 13 种操作，包括读取、设置、删除、遍历等。

- Vue3 使用 Proxy 来实现响应式系统，它可以直接监听对象而不是属性，并且可以监听动态添加的属性、删除的属性、数组索引和长度的变化。这样就避免了 Vue2 中使用 Object.defineProperty 的一些缺点，比如无法检测到对象属性的添加或删除、无法原生监听数组变化等。

- Vue3 使用 Proxy 还可以提升性能，因为它不需要递归遍历对象的所有属性来设置 getter 和 setter，而是在访问对象时才进行拦截，这样就减少了初始化的开销，并且可以对嵌套对象进行惰性处理。

### Vue3 为什么使用 CompositionAPI?
- 更好的逻辑复用：CompositionAPI 使得我们可以通过可组合的函数来实现干净、高效的逻辑复用，解决了 mixins 这种 Options API 的逻辑复用机制的缺陷。
- 更灵活的代码组织：使用 Options API 时，这些逻辑关注点被迫分散在不同的选项块中，位于文件的不同部分。而使用 CompositionAPI 时，与同一逻辑关注点相关的代码可以被分组在一起：我们不再需要在不同选项块之间跳转，就可以处理一个特定的逻辑关注点。因此，CompositionAPI 提供了更灵活的代码组织方式，使得我们可以根据自己的喜好和需求来安排代码结构。

### Vue3 对比 Vue2 做了哪些改动?
- 性能提升：Vue3 采用了更高效的编译器和响应式系统，使得渲染速度和内存占用都有显著的优化。
- 体积更小：Vue3 支持按需编译和摇树优化，使得打包后的体积比 Vue2 要更小。
- 类型推断：Vue3 更好地支持了 TypeScript，使得开发者可以更方便地使用静态类型检查和代码提示。
- 高级特性：Vue3 引入了一些新的 API 和内置组件，例如 Composition API, script setup, Teleport, Suspense 等，使得开发者可以更灵活地组织和复用逻辑，以及实现更复杂的功能。

### Node.js 的 EventLoop 是什么?
Node.js 的 EventLoop 是一种事件监听器，它在 Node.js 环境中运行，可以监听、处理和输出事件。
各个阶段概述：
- timers: 这个阶段执行由 setTimeout () 和 setInterval () 安排的回调函数。
- pending callbacks: 执行推迟到下一个循环迭代的 I/O 回调函数。
- idle, prepare: 仅在内部使用。
- poll: 获取新的 I/O 事件；执行与 I/O 相关的回调函数（几乎所有情况下，除了关闭回调函数、被定时器安排的回调函数和 setImmediate () 之外）；当适当时 node 将在此处阻塞。
- check: 执行 setImmediate () 安排的回调函数。
- close callbacks: 执行关闭回调函数，例如 socket.on ('close', ...)。

### 浏览器里的微任务和宏任务是什么?
- 宏任务（macrotask）是指那些通过标准机制安排的 JavaScript 代码，比如初始运行一个程序、事件回调、定时器等。这些代码都被放在宏任务队列中。宏任务队列中的代码按照先进先出的原则执行，每次事件循环只执行最旧的一个宏任务，然后执行所有的微任务，再执行下一个宏任务，依此类推。

- 微任务（microtask）是指那些需要在当前事件循环结束前尽快执行的 JavaScript 代码，比如 Promise 的回调、Mutation Observer 的回调等。这些代码都被放在微任务队列中。微任务队列中的代码也按照先进先出的原则执行，但是每次事件循环会执行完所有的微任务，直到微任务队列为空，再执行下一个宏任务。

微任务和宏任务的区别有以下几点：

- 微任务比宏任务有更高的优先级，因为微任务会在每个宏任务之后立即执行，而不需要等待下一个事件循环。
- 微任务可以无限制地添加到微任务队列中，而不会阻塞后续的宏任务。但是这样做可能会导致页面卡顿或者内存泄漏，因为浏览器没有机会更新渲染或者处理用户交互。
- 微任务可以访问和修改当前宏任务创建或者改变的 DOM 元素，而不会引起渲染问题，因为浏览器只会在微任务队列为空时才进行渲染。
- 微任务可以用 queueMicrotask () 方法手动创建，而宏任务通常需要用 setTimeout () 或者其他 API 创建。

### express.js 和 koa.js 的区别是什么?
- express.js 是基于回调函数（callback）来处理中间件的，而 koa.js 则是基于 async/await 语法来处理中间件的。这使得 koa.js 的中间件可以更简洁、更清晰地写出异步逻辑，也可以更好地捕获和处理异常。koa.js 的中间件遵循洋葱模型（onion model），即每个中间件都有两次执行时机，一次在请求进入时，一次在响应返回时。这样可以实现一些复杂的功能，比如日志记录、事务管理等。
- express.js 内置了很多功能，比如路由、模板引擎、错误处理等，而 koa.js 几乎不内置任何功能，只提供了一个基础的应用对象和上下文对象。这意味着 express.js 可以让开发者快速地搭建一个完整的 web 应用，而 koa.js 则需要开发者自己去选择和集成需要的功能。这也反映了两个框架的设计理念：express.js 更倾向于约定优于配置（convention over configuration），而 koa.js 更倾向于配置优于约定（configuration over convention）。

### 常见 loader 和 plugin 有哪些? 二者的区别是什么?
loader 和 plugin 是 webpack 的两种扩展机制，它们可以让 webpack 处理不同类型的文件和实现不同的功能¹²³。

- loader 是一种函数，它可以对模块的源代码进行转换，然后添加到 bundle 中。loader 可以让 webpack 处理非 JavaScript 的文件，比如 CSS、图片、TypeScript 等。loader 也可以实现一些其他的功能，比如代码检查、压缩、优化等。
- plugin 是一种对象，它可以监听 webpack 的事件，并在合适的时机对输出或者编译过程进行操作。plugin 可以实现 loader 无法实现的功能，比如拷贝文件、生成 HTML、清理目录等。

常见的 loader 有以下几种：

- style-loader: 将 CSS 代码插入到 HTML 的 style 标签中。
- css-loader: 解析 CSS 文件中的 @import 和 url() 语句，并将 CSS 转换为 JavaScript 模块。
- sass-loader: 将 Sass/SCSS 文件转换为 CSS 文件。
- less-loader: 将 Less 文件转换为 CSS 文件。
- babel-loader: 将 ES6+ 和 JSX 代码转换为兼容性更好的 JavaScript 代码。
- postcss-loader: 使用 PostCSS 处理 CSS 文件，比如添加浏览器前缀、优化样式等。
- file-loader: 将文件输出到指定目录，并返回文件的 URL。
- url-loader: 根据文件大小，将文件转换为 base64 编码的 data URL，或者使用 file-loader 处理。
- image-loader: 压缩图片文件，并返回图片的 URL。
- html-loader: 将 HTML 文件转换为字符串，并处理 HTML 中的资源引用。

常见的 plugin 有以下几种：

- HtmlWebpackPlugin: 根据模板生成 HTML 文件，并自动引入打包后的资源文件。
- MiniCssExtractPlugin: 将 CSS 代码从 JavaScript 模块中提取出来，生成单独的 CSS 文件。
- CleanWebpackPlugin: 在每次打包前清理输出目录，避免产生冗余文件。
- CopyWebpackPlugin: 将指定目录或文件拷贝到输出目录中。
- DefinePlugin: 定义全局变量，可以在编译时替换代码中的变量值。
- HotModuleReplacementPlugin: 启用模块热替换（HMR）功能，可以在不刷新浏览器的情况下更新修改后的模块。

loader 和 plugin 的区别有以下几点：

- loader 是对模块源代码的转换，而 plugin 是对输出或编译过程的操作。
- loader 是通过 use 属性在 module.rules 中配置，而 plugin 是通过 plugins 数组配置。
- loader 是按照从右到左或者从下到上的顺序执行，而 plugin 是按照 webpack 的事件钩子执行。

### webpack 如何解决开发时的跨域问题?
- 使用 webpack-dev-server 的 proxy 选项，可以将请求代理到另一个服务器上，从而避免跨域限制。例如，如果你的前端服务器运行在 http://localhost:8080，而你的后端 API 服务器运行在 http://localhost:3000，你可以在 webpack.config.js 中配置如下：
```js
module.exports = {
  // ...
  devServer: {
    proxy: {
      '/api': 'http://localhost:3000'
    }
  }
};
```

### 如何实现 tree-shaking?
tree-shaking 是一种在 webpack 中实现代码优化的技术，它可以在打包时去除那些未被使用的代码，从而减少最终的 bundle 的大小¹²³。

要实现 tree-shaking，需要满足以下几个条件：

- 使用 ES6 模块语法（import 和 export），因为它是静态的，可以在编译时确定哪些模块被导入或导出，而其他的模块系统（如 CommonJS、AMD、UMD）是动态的，无法进行静态分析。
- 使用 webpack 4 以上版本，并设置 mode 为 production，这样会自动开启 tree-shaking 功能，并且使用 UglifyJSPlugin 或者 TerserPlugin 来压缩和混淆代码，去除无用的代码。
- 在 package.json 中设置 sideEffects 为 false 或者一个数组，表示项目中的代码都是没有副作用的，或者指定哪些文件有副作用。副作用指的是模块在被执行时，除了导出值之外，还会对外部产生一些可观察的变化，比如修改全局变量、调用 console.log、创建 DOM 节点等。如果模块有副作用，那么即使它没有被使用，也不能被 tree-shaking 移除，否则可能会导致程序出错。

### 如何提高webpack构建速度?
- 使用最新版本的 webpack 和 Node.js，以及其他相关的工具和库，以便利用它们的性能改进和 bug 修复。
- 使用 loader 和 plugin 的最小数量，因为每个 loader 和 plugin 都有一定的启动开销。尽量只对需要转换的文件应用 loader，使用 include 或 exclude 选项来过滤文件。避免使用重复或冗余的 loader 和 plugin。
- 使用 cache 选项或者相关的插件，比如 cache-loader、hard-source-webpack-plugin 等，来缓存 loader 和 plugin 的执行结果，避免在每次构建时重复计算。
- 使用 thread-loader、happypack 或者 parallel-webpack 等工具，来利用多核 CPU 的优势，将构建过程分解成多个进程或线程并行执行，提高构建效率。
- 使用 babel-loader 的 cacheDirectory 选项，来缓存 babel 的编译结果。
- 减少模块的查找范围，优化 resolve 配置。比如，缩小 resolve.modules、resolve.extensions、resolve.mainFiles、resolve.descriptionFiles 的数量，避免不必要的文件系统调用；设置 resolve.symlinks 为 false，避免额外的符号链接解析；设置 resolve.cacheWithContext 为 false，避免在使用自定义解析插件时缓存过多内容。
- 使用 DllPlugin 和 DllReferencePlugin，将不经常变化的第三方库提前打包成一个动态链接库（dll），避免在每次构建时重新编译它们。
- 使用 SplitChunksPlugin 或者其他插件，将公共模块或者重复模块提取出来，避免在多个 bundle 中重复打包。
- 使用 Tree Shaking、Scope Hoisting 等技术，消除未使用的代码和模块，减少 bundle 的体积。
- 在开发环境中使用合适的 devtool 选项，选择一种较快的 source map 生成方式。一般来说，eval 类型的 source map 速度最快，但是也有一些缺点。具体可以参考 webpack 的文档。
- 在开发环境中使用 webpack-dev-server 或者 webpack-hot-middleware 等工具，启用模块热替换（HMR）功能，在代码发生变化时只重新编译和加载修改过的模块，而不是刷新整个页面。
- 在生产环境中使用 mode: 'production' 选项，并且结合 UglifyJSPlugin 或者 TerserPlugin 等插件，压缩和混淆代码，减少 bundle 的体积。
- 在生产环境中使用 compression-webpack-plugin 或者 brotli-webpack-plugin 等插件，对 bundle 进行 gzip 或者 brotli 压缩，进一步减少传输体积。

### webpack 与 vite 的区别是什么?
webpack 和 vite 的区别是什么？这是一个很有意思的问题，因为它们都是基于 JavaScript 的现代化打包工具，但是它们的设计理念和实现方式却有很大的不同¹²³。

- webpack 是一个纯打包工具，它的核心功能是将各种类型的模块（JavaScript、CSS、图片等）打包成一个或多个 bundle 文件，供浏览器或其他环境加载和执行。webpack 通过 loader 和 plugin 的机制，可以支持各种复杂的转换和优化操作，比如编译 TypeScript、压缩代码、拆分代码等。webpack 的优点是功能强大、灵活、成熟，有着庞大的社区和生态系统；缺点是配置复杂、启动慢、热更新慢。
- vite 是一个更上层的工具链方案，它的核心功能是提供一个快速的开发服务器，利用浏览器原生支持的 ES Module 语法，实现按需编译和加载模块，无需打包和热更新。vite 通过 esbuild 预构建依赖，通过 rollup 打包生产环境的代码，通过插件支持各种自定义操作。vite 的优点是启动快、热更新快、配置简单、开发体验好；缺点是功能相对较少、兼容性较差、生态系统较小。

### webpack 怎么配置多页应用?
- 定义多个入口文件，每个页面对应一个入口文件，可以使用动态生成的对象或者数组来表示。
- 使用 HtmlWebpackPlugin 插件，为每个页面生成一个 HTML 文件，并且自动注入对应的入口文件和其他资源。可以使用 map 或者 reduce 方法来根据入口文件数组生成多个 HtmlWebpackPlugin 实例。
- 使用 optimization.splitChunks 选项，将公共的模块或者第三方库提取出来，避免在多个页面中重复打包。
- 使用 devServer.historyApiFallback 选项，让开发服务器能够响应多个页面的路由请求，并返回对应的 HTML 文件。

### swc、esbuild 是什么?
- swc 是一个 JavaScript/TypeScript 编译器，它可以将 JavaScript/TypeScript 代码转换为兼容性更好的 JavaScript 代码，支持 ES6+、JSX、TS 等语法。swc 的目标是完全替代 Babel，并且提供更快的编译速度和更小的输出体积。swc 还提供了一个打包工具 spack，可以将多个模块打包成一个 bundle 文件。
- esbuild 是一个 JavaScript 打包器，它可以将多个 JavaScript/TypeScript 模块打包成一个或多个 bundle 文件，并且支持压缩、拆分、Tree Shaking 等优化操作。esbuild 的目标是完全替代 webpack，并且提供更快的打包速度和更简单的配置方式。esbuild 还提供了一个转换工具，可以将 JavaScript/TypeScript 代码转换为兼容性更好的 JavaScript 代码，但不支持 polyfill 和插件。

