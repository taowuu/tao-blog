### 手写节流throttle、debounce
节流 throttle 和防抖 debounce 是两种常用的函数优化技术，它们的目的是减少函数在短时间内被频繁调用的次数，从而提高性能和用户体验。它们的区别是：

- 节流 throttle 是指在一定时间间隔内，只执行函数的第一次或最后一次调用，忽略其他的调用。节流可以保证函数在规定的时间内至少执行一次，适用于需要按时间均匀触发的场景，比如滚动事件、拖拽事件等。
- 防抖 debounce 是指在一定时间间隔内，只执行函数的最后一次调用，取消其他的调用。防抖可以避免函数被过度触发，适用于需要等待用户输入停止后再触发的场景，比如输入框搜索、窗口大小调整等。

手写节流 throttle 和防抖 debounce 的代码如下：

```js
// 节流 throttle
function throttle(fn, delay) {
  // 定义一个标志位，表示是否可以执行函数
  let flag = true;
  // 返回一个包装后的函数
  return function (...args) {
    // 如果标志位为 false，表示正在执行函数，直接返回
    if (!flag) return;
    // 否则，将标志位设为 false，并且在 delay 时间后恢复为 true
    flag = false;
    setTimeout(() => {
      flag = true;
    }, delay);
    // 调用原函数，并绑定 this 和参数
    fn.apply(this, args);
  };
}

// 防抖 debounce
function debounce(fn, delay) {
  // 定义一个定时器变量，用于存储和清除定时器
  let timer = null;
  // 返回一个包装后的函数
  return function (...args) {
    // 如果定时器存在，表示已经触发过函数，需要清除定时器并重新计时
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    // 否则，创建一个新的定时器，并且在 delay 时间后执行原函数
    timer = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}
```

### 手写发布订阅
你好，这是Bing。我可以帮你了解js手写发布订阅模式。😊

发布订阅模式是一种设计模式，它可以让多个对象之间实现一对多的关系，当一个对象的状态发生变化时，它可以通知所有订阅了它的对象。¹²³

js手写发布订阅模式的基本思路是：

- 创建一个事件中心对象，它有一个存储订阅事件的列表属性，以及订阅、取消订阅、发布和只发布一次的方法。
- 订阅方法（on）接收一个事件名和一个回调函数，如果列表中存在该事件名，就将回调函数添加到对应的数组中，否则就创建一个新的数组并添加回调函数。
- 取消订阅方法（off）接收一个事件名和一个回调函数，如果列表中存在该事件名，就从对应的数组中移除该回调函数，如果数组为空，就删除该事件名。
- 发布方法（emit）接收一个事件名和一些参数，如果列表中存在该事件名，就遍历对应的数组并依次执行回调函数，并传入参数。
- 只发布一次方法（once）接收一个事件名和一个回调函数，使用订阅方法添加到列表中，并在回调函数内部使用取消订阅方法移除自身。

以下是一个简单的示例代码⁴：

```js
// 创建一个事件中心对象
class EventEmitter {
  constructor() {
    // 初始化一个空对象存储订阅事件
    this.events = {};
  }
  // 订阅方法
  on(eventName, callback) {
    // 如果已经有该事件名，就将回调函数添加到数组中
    if (this.events[eventName]) {
      this.events[eventName].push(callback);
    } else {
      // 否则就创建一个新的数组并添加回调函数
      this.events[eventName] = [callback];
    }
  }
  // 取消订阅方法
  off(eventName, callback) {
    // 如果有该事件名，就从数组中移除回调函数
    if (this.events[eventName]) {
      this.events[eventName] = this.events[eventName].filter(
        (cb) => cb !== callback
      );
      // 如果数组为空，就删除该事件名
      if (this.events[eventName].length === 0) {
        delete this.events[eventName];
      }
    }
  }
  // 发布方法
  emit(eventName, ...args) {
    // 如果有该事件名，就遍历数组并执行回调函数
    if (this.events[eventName]) {
      this.events[eventName].forEach((cb) => cb(...args));
    }
  }
  // 只发布一次方法
  once(eventName, callback) {
    // 定义一个包装函数，在执行回调函数后取消订阅
    const wrapFunc = (...args) => {
      callback(...args);
      this.off(eventName, wrapFunc);
    };
    // 使用订阅方法添加到列表中
    this.on(eventName, wrapFunc);
  }
}

// 测试代码
// 创建一个实例
const event = new EventEmitter();
// 定义两个回调函数
const handle1 = (...args) => console.log("handle1", ...args);
const handle2 = (...args) => console.log("handle2", ...args);
// 订阅test事件
event.on("test", handle1);
event.on("test", handle2);
// 发布test事件
event.emit("test", "hello", "world"); // handle1 hello world; handle2 hello world
// 取消订阅handle1
event.off("test", handle1);
// 再次发布test事件
event.emit("test", "hi"); // handle2 hi
// 使用只发布一次方法订阅once事件
event.once("once", handle1);
```

### 手写 AJAX

AJAX 是 Asynchronous JavaScript And XML 的简称，它允许我们在不刷新整个页面的情况下，就可以异步获取数据，并更新页面的部分内容。

手写 AJAX 的关键步骤如下：

1. 创建 XMLHttpRequest 对象，这是 AJAX 的主要接口，用于浏览器与服务器之间的通信。
2. 调用 open () 方法，指定 HTTP 请求的参数，比如方法、URL、是否异步等。
3. 调用 send () 方法，发出 HTTP 请求，如果是 POST 请求，还需要设置请求头和发送数据体。
4. 监听 readyState 属性和 onreadystatechange 事件，获取服务器返回的数据和状态码。
5. 解析服务器返回的数据，根据需要更新页面的部分内容。

下面是一个简单的例子，使用 GET 方法向服务器发送一个请求，并在控制台打印出返回的数据：

```javascript
// 创建 XMLHttpRequest 对象
var xhr = new XMLHttpRequest();

// 指定 HTTP 请求的参数
xhr.open('GET', 'http://www.example.com', true);

// 发出 HTTP 请求
xhr.send(null);

// 监听 readyState 属性和 onreadystatechange 事件
xhr.onreadystatechange = function() {
  // 判断请求是否完成
  if (xhr.readyState === 4) {
    // 判断请求是否成功
    if (xhr.status === 200) {
      // 获取服务器返回的数据
      var data = xhr.responseText;
      // 在控制台打印数据
      console.log(data);
    } else {
      // 处理请求失败的情况
      console.error('请求失败：' + xhr.status);
    }
  }
};
```

### 手写深拷贝
深拷贝和浅拷贝的区别就是如何处理引用类型，结果跟着原值变的就是浅拷贝，不会跟着变的就是深拷贝。

手写深拷贝的方法有两种：

1. 通过 JSON 反序列化 来实现。

```javascript
const B = JSON.parse(JSON.stringify(A));
```

这种方法最简单，但是也有缺点，就是 JSON 不支持的数据类型，都拷贝不了，比如函数、undefined、Symbol、循环引用等。

2. 通过递归遍历对象的属性来实现。

```javascript
function deepClone(obj) {
  // 判断是否是对象或数组
  if (typeof obj !== 'object' || obj === null) {
    // 如果不是，直接返回
    return obj;
  }
  // 初始化结果
  let result;
  if (obj instanceof Array) {
    // 如果是数组，创建一个空数组
    result = [];
  } else {
    // 如果是对象，创建一个空对象
    result = {};
  }
  // 遍历对象的属性
  for (let key in obj) {
    // 如果是自身的属性，不是原型链上的
    if (obj.hasOwnProperty(key)) {
      // 递归调用深拷贝，将属性值也拷贝过来
      result[key] = deepClone(obj[key]);
    }
  }
  // 返回结果
  return result;
}
```

这种方法可以处理更多的数据类型，但是也有缺点，就是可能会出现栈溢出的问题，如果对象层级太深或者存在循环引用。

### 手写数组去重
1. 通过双重 for 循环和 splice 方法实现。

```javascript
function unique(arr) {
  // 定义一个新数组
  let result = [];
  // 外层循环遍历原数组
  for (let i = 0; i < arr.length; i++) {
    // 内层循环遍历新数组
    for (let j = 0; j < result.length; j++) {
      // 如果新数组中已经存在当前元素，就跳出内层循环
      if (arr[i] === result[j]) {
        break;
      }
    }
    // 如果内层循环完整执行，说明新数组中没有当前元素，就将其添加到新数组中
    if (j === result.length) {
      result.push(arr[i]);
    }
  }
  // 返回新数组
  return result;
}
```

这种方法最直观，但是也最低效，因为需要两层循环，时间复杂度是 O(n^2)。

2. 通过 indexOf 方法实现。

```javascript
function unique(arr) {
  // 定义一个新数组
  let result = [];
  // 遍历原数组
  for (let i = 0; i < arr.length; i++) {
    // 判断当前元素在新数组中是否存在，如果不存在，就将其添加到新数组中
    if (result.indexOf(arr[i]) === -1) {
      result.push(arr[i]);
    }
  }
  // 返回新数组
  return result;
}
```

这种方法只需要一层循环，效率高些，但是还是需要遍历新数组来判断是否存在重复元素。

3. 通过 Set 结构实现。

```javascript
function unique(arr) {
  // 利用 Set 结构的特性，将数组转化为 Set 容器，自动去除重复元素
  let set = new Set(arr);
  // 将 Set 容器展开存入数组中
  let result = [...set];
  // 返回新数组
  return result;
}
```

### 手写简化版 Promise
你好，这是必应。我可以帮你了解一下手写简化版 Promise 的方法。😊

Promise 是一种异步编程的解决方案，它可以让我们以同步的方式书写异步的代码，避免了回调地狱的问题。¹

手写简化版 Promise 的关键步骤如下：¹²³

1. 定义一个 Promise 类，它接收一个 executor 函数作为参数，该函数有两个参数，分别是 resolve 和 reject。
2. 在 Promise 类中，定义三个状态：pending（等待）、fulfilled（成功）、rejected（失败），以及两个属性：value（成功的值）和 reason（失败的原因）。
3. 在 Promise 类中，定义一个 resolve 方法，它接收一个 value 作为参数，将状态改为 fulfilled，并执行成功的回调函数（如果有）。
4. 在 Promise 类中，定义一个 reject 方法，它接收一个 reason 作为参数，将状态改为 rejected，并执行失败的回调函数（如果有）。
5. 在 Promise 类中，定义一个 then 方法，它接收两个参数，分别是 onFulfilled 和 onRejected，分别表示成功和失败的回调函数。
6. 在 then 方法中，根据当前的状态，执行相应的回调函数，或者将回调函数存入数组中，等待状态改变后再执行。

下面是一个简单的例子，使用 Promise 实现一个异步操作，并在 then 方法中获取结果或捕获错误：

```javascript
// 定义 Promise 类
class Promise {
  // 构造函数接收一个 executor 函数
  constructor(executor) {
    // 定义三个状态
    this.PENDING = "pending";
    this.FULFILLED = "fulfilled";
    this.REJECTED = "rejected";
    // 初始化状态为 pending
    this.status = this.PENDING;
    // 初始化 value 和 reason
    this.value = undefined;
    this.reason = undefined;
    // 定义两个数组存放成功和失败的回调函数
    this.onFulfilledCallbacks = [];
    this.onRejectedCallbacks = [];
    // 定义 resolve 方法
    const resolve = (value) => {
      // 只有状态为 pending 才能改变
      if (this.status === this.PENDING) {
        // 将状态改为 fulfilled
        this.status = this.FULFILLED;
        // 保存成功的值
        this.value = value;
        // 执行成功的回调函数
        this.onFulfilledCallbacks.forEach((fn) => fn());
      }
    };
    // 定义 reject 方法
    const reject = (reason) => {
      // 只有状态为 pending 才能改变
      if (this.status === this.PENDING) {
        // 将状态改为 rejected
        this.status = this.REJECTED;
        // 保存失败的原因
        this.reason = reason;
        // 执行失败的回调函数
        this.onRejectedCallbacks.forEach((fn) => fn());
      }
    };
    // 执行 executor 函数，并传入 resolve 和 reject 方法
    try {
      executor(resolve, reject);
    } catch (error) {
      // 如果出错，直接调用 reject 方法
      reject(error);
    }
  }
  // 定义 then 方法
  then(onFulfilled, onRejected) {
    // 根据当前的状态，执行相应的回调函数
    if (this.status === this.FULFILLED) {
      onFulfilled(this.value);
    }
    if (this.status === this.REJECTED) {
      onRejected(this.reason);
    }
    // 如果状态还是 pending，将回调函数存入数组中
    if (this.status === this.PENDING) {
      this.onFulfilledCallbacks.push(() => onFulfilled(this.value));
      this.onRejectedCallbacks.push(() => onRejected(this.reason));
    }
  }
}
```

### 手写 Promise.all
Promise.all 的作用是等待所有的 promise 都完成（resolved）或者有一个失败（rejected），然后根据结果返回一个数组或者一个错误。

手写 Promise.all 的关键步骤如下：

1. 定义一个 Promise.all 方法，它接收一个 iterable 作为参数，判断它是否是可迭代对象，如果不是，抛出错误。
2. 定义一个 result 数组，用于存放每个 promise 的结果，以及一个 count 变量，用于记录完成的 promise 的数量。
3. 定义一个 resolve 函数，它接收一个 index 和 value 作为参数，将 value 存入 result 数组的对应位置，并将 count 加一，如果 count 等于 iterable 的长度，说明所有的 promise 都完成了，就返回 result 数组。
4. 定义一个 reject 函数，它接收一个 reason 作为参数，直接返回 reason 作为错误。
5. 遍历 iterable 中的每个元素，判断它是否是 promise 实例，如果是，就调用它的 then 方法，并传入 resolve 和 reject 函数；如果不是，就直接调用 resolve 函数，并传入当前索引和元素值。
6. 返回一个新的 promise 实例，并传入 resolve 和 reject 函数。

下面是一个简单的例子，使用 Promise.all 发送多个请求，并在 then 方法中获取所有结果或捕获错误：

```javascript
// 定义 Promise.all 方法
Promise.all = function (iterable) {
  // 判断参数是否是可迭代对象
  if (!iterable[Symbol.iterator]) {
    throw new TypeError("iterable must be iterable");
  }
  // 定义 result 数组和 count 变量
  let result = [];
  let count = 0;
  // 定义 resolve 函数
  function resolve(index, value) {
    // 将 value 存入 result 数组
    result[index] = value;
    // 将 count 加一
    count++;
    // 如果 count 等于 iterable 的长度，说明所有的 promise 都完成了
    if (count === iterable.length) {
      // 返回 result 数组
      return result;
    }
  }
  // 定义 reject 函数
  function reject(reason) {
    // 返回 reason 作为错误
    return reason;
  }
  // 遍历 iterable 中的每个元素
  for (let i = 0; i < iterable.length; i++) {
    let item = iterable[i];
    // 判断元素是否是 promise 实例
    if (item instanceof Promise) {
      // 调用 then 方法，并传入 resolve 和 reject 函数
      item.then((value) => resolve(i, value), reject);
    } else {
      // 直接调用 resolve 函数，并传入当前索引和元素值
      resolve(i, item);
    }
  }
  // 返回一个新的 promise 实例，并传入 resolve 和 reject 函数
  return new Promise((resolve, reject) => {
    resolve(resolve);
    reject(reject);
  });
};

// 使用 Promise.all 发送多个请求
const p = Promise.all([
  fetch("https://www.baidu.com"),
  fetch("https://www.google.com"),
  fetch("https://www.bing.com"),
]);

// 在 then 方法中获取所有结果或捕获错误
p.then(
  (data) => {
    console.log(data); // 打印一个包含三个响应对象的数组
  },
  (err) => {
    console.log(err); // 打印第一个失败结果
  }
);
```

### 手写事件委托
1. 定义一个委托函数，它接收三个参数，分别是父元素、子元素选择器、事件类型和回调函数。
2. 在委托函数中，获取父元素，并为其添加事件监听器，指定事件类型和回调函数。
3. 在回调函数中，获取触发事件的目标元素，并判断它是否匹配子元素选择器，如果是，就执行原始的回调函数；如果不是，就向上遍历其祖先元素，直到找到匹配的子元素或者到达父元素为止。

下面是一个简单的例子，使用事件委托为 ul 中的 li 元素添加点击事件，并在控制台打印出 li 的内容：

```javascript
// 获取 ul 元素
const ul = document.querySelector("ul");

// 定义委托函数
function delegate(parent, selector, type, callback) {
  // 为父元素添加事件监听器
  parent.addEventListener(type, function (e) {
    // 获取触发事件的目标元素
    let target = e.target;
    // 判断目标元素是否匹配子元素选择器
    if (target.matches(selector)) {
      // 如果是，就执行原始的回调函数，并传入目标元素和事件对象
      callback(target, e);
    } else {
      // 如果不是，就向上遍历其祖先元素
      while (target !== parent) {
        // 获取目标元素的父元素
        target = target.parentNode;
        // 判断父元素是否匹配子元素选择器
        if (target.matches(selector)) {
          // 如果是，就执行原始的回调函数，并传入父元素和事件对象
          callback(target, e);
          // 跳出循环
          break;
        }
      }
    }
  });
}

// 使用委托函数为 ul 中的 li 元素添加点击事件
delegate(ul, "li", "click", function (li, e) {
  // 在控制台打印出 li 的内容
  console.log(li.textContent);
});
```

### 手写可拖曳 div
你好，这是必应。我可以帮你了解一下手写可拖曳 div 的方法。😊

可拖曳 div 是一种常见的交互效果，它可以让用户通过鼠标拖动，改变 div 的位置。¹²

手写可拖曳 div 的关键步骤如下：¹²³

1. 定义一个 div 元素，并设置它的样式，比如宽度、高度、背景色、边框等。
2. 定义一个 dragging 变量，用于标记是否正在拖动，以及一个 position 变量，用于记录鼠标按下时的坐标。
3. 为 div 元素添加 mousedown 事件监听器，当鼠标按下时，将 dragging 设为 true，并记录当前鼠标的坐标到 position 中。
4. 为 document 添加 mousemove 事件监听器，当鼠标移动时，判断 dragging 是否为 true，如果是，就计算鼠标移动的距离，并根据距离改变 div 的位置。
5. 为 document 添加 mouseup 事件监听器，当鼠标松开时，将 dragging 设为 false，并清空 position。

下面是一个简单的例子，使用原生 JS 实现一个可拖曳的 div：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>手写可拖曳div</title>
    <style>
      .box {
        width: 200px;
        height: 200px;
        background-color: pink;
        border: 1px solid black;
        position: absolute;
        left: 100px;
        top: 100px;
      }
    </style>
  </head>
  <body>
    <div class="box"></div>
    <script>
      // 获取 div 元素
      const box = document.querySelector(".box");
      // 定义 dragging 变量和 position 变量
      let dragging = false;
      let position = null;
      // 为 div 元素添加 mousedown 事件监听器
      box.addEventListener("mousedown", function (e) {
        // 将 dragging 设为 true
        dragging = true;
        // 记录当前鼠标的坐标到 position 中
        position = [e.clientX, e.clientY];
      });
      // 为 document 添加 mousemove 事件监听器
      document.addEventListener("mousemove", function (e) {
        // 判断 dragging 是否为 true
        if (dragging) {
          // 计算鼠标移动的距离
          const x = e.clientX - position[0];
          const y = e.clientY - position[1];
          // 根据距离改变 div 的位置
          box.style.left = parseInt(box.style.left) + x + "px";
          box.style.top = parseInt(box.style.top) + y + "px";
          // 更新 position 的值
          position = [e.clientX, e.clientY];
        }
      });
      // 为 document 添加 mouseup 事件监听器
      document.addEventListener("mouseup", function (e) {
        // 将 dragging 设为 false
        dragging = false;
        // 清空 position
        position = null;
      });
    </script>
  </body>
</html>
```

### js大数相加
js 大数相加的问题是由于 js 在存放整数的时候有一个安全范围，一旦数字超过这个范围就会损失精度，导致运算结果不准确。

js 大数相加的方法有以下几种：

1. 使用 BigInt 类型。这是 ES10 新增的一种数据类型，可以表示任意精度的整数，不受安全范围的限制。

```javascript
// 使用 BigInt 类型表示大数
let a = BigInt("9007199254740991");
let b = BigInt("1234567899999999999");
// 使用 + 运算符进行相加
let sum = a + b;
// 打印结果
console.log(sum); // 1243575099254740990n
```

这种方法最简单，但是需要注意，BigInt 类型不能和其他类型混合运算，也不能直接用于 Math 对象的方法，需要进行类型转换。

2. 使用字符串类型。这是一种通用的方法，可以将大数转换为字符串，然后按位进行相加，处理进位和补齐等细节。

```javascript
// 定义一个大数相加的函数
function add(a, b) {
  // 取两个数字的最大长度
  let maxLength = Math.max(a.length, b.length);
  // 用 0 去补齐长度
  a = a.padStart(maxLength, 0); // "0009007199254740991"
  b = b.padStart(maxLength, 0); // "1234567899999999999"
  // 定义加法过程中需要用到的变量
  let t = 0; // 每一位的临时结果
  let f = 0; // 进位
  let sum = ""; // 最终结果
  for (let i = maxLength - 1; i >= 0; i--) {
    // 按位相加，注意要转为数字
    t = parseInt(a[i]) + parseInt(b[i]) + f;
    // 判断是否进位
    f = Math.floor(t / 10);
    // 将每一位的结果拼接到 sum 中，注意要转为字符串，并且是高位在前低位在后
    sum = (t % 10) + sum;
  }
  // 如果最后还有进位，要在最前面加上进位
  if (f == 1) {
    sum = "1" + sum;
  }
  // 返回结果
  return sum;
}

// 调用函数进行相加
let a = "9007199254740991";
let b = "1234567899999999999";
let sum = add(a, b);
// 打印结果
console.log(sum); // "1243575099254740990"
```
