# 1. Ajax-Fetch-Axios三者有什么区别
* 三者都用于网络请求
* ajax 是异步网络请求的技术统称
* fetch 是原生 api
* axios 是第三方网络请求库
* ajax 手写实现
```javascript
// XMLHttpRequest
function ajax1(url, successFn) {
    const xhr = new XMLHttpRequest()
    xhr.open('GET', url, false)
    xhr.onreadystatechange = function() {
        if(xhr.readyState === 4 && xhr.status === 200) {
            successFn(xhr.responseText)
        }
    }
    xhr.send(null)
}
// fetch
function ajax2(url, successFn) {
    return fetch(url).then((res) => res.json())
}
// axios 
```
# 2. 防抖和节流有什么区别
* 防抖，抖动停止后再触发回调
* 例如等待搜索框输入完毕后再触发搜索
```javascript
function debounce(fn ,delay = 200) {
    let timer = 0
    return function() {
        if(timer) clearTimeout(timer)
        timer = setTimeout(() => {
            fn.apply(this, arguments)
            timer = 0
        }, delay)
    }
}
```
* 节流，节省频繁交互沟通的成本
* 例如给拖拽回调的触发限定一个时间
```javascript
function throttle(fn ,delay = 200) {
    let timer = 0
    return function() {
        if(timer) return
        timer = setTimeout(() => {
            fn.apply(this, arguments)
            timer = 0
        }, delay)
    }
}
```
# 3. px-%-em-rem-vw-vh有什么区别
* px 绝对单位
* % 相对于父元素
* em 相对于当前元素的 font size
* rem 相对于根元素的 font size
* vh 屏幕高度 1%
* vw 屏幕宽带 1%
* vmin 两者最小值（vmax
<!--  -->
# 4. 什么时候不能使用箭头函数
* 没有 arguments
* 不能修改 this
* 对象方法不能获取到 this
* 无法作为构造函数
* 上下文回调函数无法获取 this
* vue 生命周期和 method 不能使用
* class 可以使用（react
<!--  -->
# 5. TCP 三次握手和四次挥手
* 建立 tcp 连接确保双方都有收发数据的能力
* 通过 http 协议传输内容
* 三次握手
    * c 发包 s 接收（s 知道有 c 连接
    * s 发包 c 接收（c 知道 s 收到消息
    * c 正式发数据
* 四次挥手
    * c 发包 s 接收（s 知道请求结束
    * s 发包 c 接收（c 等待关闭
    * s 发包 c 接收（c 知道可以关闭
    * c 发包 s 接收（s 正式关闭
<!--  -->
# 6. for-in 和 for-of 有什么区别
* in 遍历 key（不能 map set
* of 遍历 val（不能对象
* in 用于枚举（一一举例出来
* of 用于迭代（可根据当前得到下一个
<!--  -->
# 7. map 和 object 区别
* map 保持插入顺序
* map key 可以是任意类型
* object key 只能 数字 字符串 symbol
* map 可迭代
# 8. for await of
* 遍历异步
# 9. 盒模型
1. border box = content + padding + border + margin
2. offsetHeight = content + padding + border
3. clientHeight = content + padding
4. scrollHeight = 实际尺寸 + padding
# 10. HTMLCollection和NodeList有什么区别
1. node list 包含 text comment
# 11. computed 和 watch 区别
1. computed 用于产生新数据
2. watch 用于监听现有数据
3. computed 有缓存 method 没有
# 12. vue 组件通信方式
1. prop emit
2. eventbus
3. attrs
4. parent
5. refs 子组件
6. provide inject
# 13. Vuex中action和mutation有什么区别
1. mutation 操作是原子性，同步的
2. action 可包含多个 mutation 可异步
# 14. JS严格模式有什么特点
- 全局变量必须声明
- 禁止使用 with
- 创建 eval 作用域
- 禁止 this 指向全局作用域
- 函数参数不能重名
# 15. 跨域为何需要 options 请求？
options 请求就是对 CORS 跨域请求之间的一次预检查
# 16. 内存泄漏的场景有哪些？
1. 全局变量，事件，定时器的引用组件销毁时未删除
# 17. 垃圾回收算法
1. 引用计数（清除未被引用的，循环引用缺陷
2. 标记清除（从根遍历各个属性，得不到对象就删除
# 18. 浏览器和 node 事件循环有什么区别
1. 微任务，dom 渲染， 宏任务
2. node 按类型优先级
# 19. for 为什么快于 foreach
1. foreach 每次需要初始化函数
# 20. node 进程如何通信
1. 进程是资源分配的最小单位
2. 线程是运算调度的最小单位
3. webworker 开启进程
4. child_process fork 开启 send 传消息
5. cluster 开启多个
# 21. 什么是 js brige
1. js 调用原生app api的格式
2. 使用 url scheme 通信
# 22. requestIdleCallback 和requestAnimationFrame 有什么区别
1. requestIdleCallback 空闲时执行
2. 和requestAnimationFrame 每次渲染完都执行
# 23. Vue每个生命周期都做了什么
1. before create
    创建空白 vue 实例
    data method 未初始化
2. created
    完成响应式绑定
    data method 可调用
    未开始渲染模板
3. before mount
    编译模板，render 生成 vdom
    没有开始渲染 dom
4. mounted
    完成 dom 渲染
    组件创建完成
    进入运行阶段
5. before update
    data 发生变化后
    准备更新 dom
6. updated
    data 变化且 dom 更新完成
    修改 data 可能死循环
7. before unmount
    组件进入销毁阶段
    可解绑事件
8. unmounted
    组件销毁完成
# 24. vue 什么时候操作 dom
1. mounted 和 updated 都不能保证组件挂载完成
2. 使用 nextTick
# 25. ajax 放在那个周期
1. mounted
# 26. vue3 composition api 生命周期区别
1. setup 代替 create
2. hook 形式 onMounted() 代替 mounted
# 27. vue react diff 区别
1. react 仅右移动，把原来右边挤到左边
2. vue2 双端比较
3. vue3 最长递增子序列作为整体
# 28. vue for 为何使用 key
1. diff 会根据 key 判断元素是否删除
2. 匹配了key 只移动性能好
3. 未匹配 key 则删除重新渲染，性能差
# 29. vue 内存路由
1. 在当前页面触发不同组件的渲染
2. 路由不会变化
# 30. 移动端H5点击有300ms延迟
1. 监听 touchend 使用自定义的 click 把默认 click 禁掉
2. 现代浏览器改进 width=device-width
# 31. token和cookie有什么区别
1. token 需要自己传递（authorization
2. 需要自己存储
3. 没有跨越限制
4. 保存用户全部信息
# 32. jwt (json web token
1. 后端验证登录成功后返回 taoken
2. 前端自行存储
3. 以后访问后端都带上 token
# 33. session和JWT哪个更好
1. session 存储在服务端可以快速封禁某用户
2. 占用服务端内存
3. 多进程不好同步（redis
4. 有跨越限制
5. jwt 不占用服务端内存，多进程无影响
6. 无跨域
7. 服务端密钥泄露则用户信息全部丢失
8. 体积大于 cookie
# 34. 如何实现SSO单点登录
1. 设置 cookie domain=主域名
2. 登录校验都转发到 sso 负责
3. oauth 由第三方下发 token 并且去第三方认证
# 35. HTTP协议和UDP协议有什么区别
1. http 应用层，tcp udp 传输层
2. tcp 有连接有断开，稳定传输
3. udp 无连接无断开，不稳定但效率高
# 36. HTTP协议1.0和1.1和2.0有什么区别
1. 1.0 支持基本的 get post
2. 1.1 支持缓存策略，长连接，断定续传206，支持 put delete 用于 restful api
3. 2.0 压缩 header，多路复用（一次连接多个并行请求，服务端推送
# 37. 什么是HTTPS中间人攻击，如何预防
1. 中间人伪造公钥给客户端，通过自己的私钥解密拿到客户端和服务端通信的密钥
2. 服务端使用正规的证书响应请求
# 38. script标签的 defer 和 async 有什么区别
1. defer 并行下载 js，dom 解析完后再执行
2. async 并行下载 js 后立即执行
# 39. prefetch和dns-prefetch分别是什么
1. preload 优先加载
2. prefetch 空闲时加载
3. dns-prefetch dns 预查寻
4. preconnect dns 预连接
# 40. 前端攻击手段有哪些，该如何预防
1. xss（特殊字符替换
2. csrf（服务端下发 token，校验 referrer，cookie 设置 samesite
3. 点击劫持（sameorigin 禁止iframe跨域加载
4. ddos
5. sql 注入
# 41. WebSocket和HTTP协议有什么区别
1. ws 可以双端通信
2. 没有跨越限制
# 42. WebSocket和HTTP长轮询的区别
1. http 需要等待服务端返回才能再次请
2. ws 可以双方任意发送
# 43. 从输入URL 到网页显示的完整过程
1. dns解析，http请求
2. 解析 dom树，cssom树，render树
3. 计算dom尺寸定位，绘制到页面，执行js
# 44. 网页重绘repaint和重排reflow有什么区别
1. repaint 颜色变化
2. reflow 位置变化
# 45. 减少重排
1. 集中修改样式
2. 先 display none 或 使用 bfc
3. 使用节流防抖
4. createdocumentFragment 批量操作 dom
5. 使用 css3 或 requestAnimationFrame 做动画
# 46. 如何实现网页多标签tab通讯
1. ws
2. localstorage
3. sharedworker 
# 47. 如何实现网页和iframe之间的通讯
1. postMessage 发送
2. on message 接受
# 48. 请描述koa2的洋葱圈模型
1. 捕获再冒泡
# 49. H5页面如何进行首屏优化
1. 路由懒加载
2. ssr
3. app 预取（js bridge
4. 图片懒加载（提前设置图片尺寸防止重排
5. hybrid（提前下载资源到app内部
6. 分页
# 50. 后端一次性返回10w条数据，你该如何渲染
1. 自定义 node 中间层拆分数据
2. 虚拟列表（只渲染可视区域，随浏览器滚动创建销毁dom
# 51. 前端常用的设计模式和使用场景
1. 单例模式（vuex store
2. 工厂模式（createElement
3. 代理模式（proxy
4. 观察者（addEventlistener
5. 发布订阅（on，emit
6. 装饰器（原功能不变增加新功能，decorator
# 52. 观察者模式和发布订阅模式的区别
1. 主体和观察者直接绑定
2. 发布者和观察者互相不认识，需要中间媒介
# 53. 在实际工作中，你对Vue做过哪些优化
1. v-show
2. v-for 使用 key
3. computed 缓存
4. keep alive 缓存组件
5. 异步组件（使用时才加载
6. 路由懒加载
7. ssr
# 54. 你在使用Vue过程中遇到过哪些坑
1. 内存泄漏全局变量未销毁
2. vue2 响应式缺陷
3. 路由切换滚到顶部（缓存原页面数据和scrolltop
4. mpa+app webview
# 55. 如何统一监听Vue组件报错
1. window.onerror（识别不了 vue，可识别异步
2. errorCapture（监听下级，返回 fasle 不会向上传播
3. errorHanler（监听所有组件
# 56. 如果一个H5很慢，如何排查性能问题
1. 加载慢（cdn，路由懒加载，组件异步加载，http缓存
2. 渲染慢（优化服务端接口，优化组件内部逻辑，ssr
# 57. 手写一个JS函数，实现数组扁平化Array Flatten
```javascript
/**
 * 数组扁平化，使用 push
 * @param arr arr
 */
export function flatten1(arr: any[]): any[] {
    const res: any[] = []

    arr.forEach(item => {
        if (Array.isArray(item)) {
            item.forEach(n => res.push(n))
        } else {
            res.push(item)
        }
    })

    return res
}

/**
 * 数组扁平化，使用 concat
 * @param arr arr
 */
export function flatten2(arr: any[]): any[] {
    let res: any[] = []

    arr.forEach(item => {
        res = res.concat(item)
    })

    return res
}

/**
 * 数组深度扁平化，使用 push
 * @param arr arr
 */
export function flattenDeep1(arr: any[]): any[] {
    const res: any[] = []

    arr.forEach(item => {
        if (Array.isArray(item)) {
            const flatItem = flattenDeep1(item) // 递归
            flatItem.forEach(n => res.push(n))
        } else {
            res.push(item)
        }
    })

    return res
}
// // 功能测试
// const arr = [1, [2, [3], 4], 5]
// console.info( flatten2(arr) )

/**
 * 数组深度扁平化，使用 concat
 * @param arr arr
 */
export function flattenDeep2(arr: any[]): any[] {
    let res: any[] = []

    arr.forEach(item => {
        if (Array.isArray(item)) {
            const flatItem = flattenDeep2(item) // 递归
            res = res.concat(flatItem)
        } else {
            res = res.concat(item)
        }
    })

    return res
}


// // 功能测试
// const arr = [1, [2, [3, ['a', [true], 'b'], 4], 5], 6]
// console.info( flattenDeep2(arr) )
```
# 58. 手写一个getType函数，获取详细的数据类型
```javascript
export function getType(x: any): string {
    const originType = Object.prototype.toString.call(x) // '[object String]'
    const spaceIndex = originType.indexOf(' ')
    const type = originType.slice(spaceIndex + 1, -1) // 'String'
    return type.toLowerCase() // 'string'
}

// // 功能测试
// console.info( getType(null) ) // 'null'
// console.info( getType(undefined) )
// console.info( getType(100) )
// console.info( getType('abc') )
// console.info( getType(true) )
// console.info( getType(Symbol()) )
// console.info( getType({}) )
// console.info( getType([]) )
// console.info( getType(() => {}) )
```
# 59. new 一个对象内部发生了什么，手写代码表示
```javascript
export function customNew<T>(constructor: Function, ...args: any[]): T {
    // 1. 创建一个空对象，继承 constructor 的原型
    const obj = Object.create(constructor.prototype)
    // 2. 将 obj 作为 this ，执行 constructor ，传入参数
    constructor.apply(obj, args)
    // 3. 返回 obj
    return obj
}

// class Foo {
//     // 属性
//     name: string
//     city: string
//     n: number

//     constructor(name: string, n: number) {
//         this.name = name
//         this.city = '北京'
//         this.n = n
//     }

//     getName() {
//         return this.name
//     }
// }

// const f = new Foo('双越', 100)
// // const f = customNew<Foo>(Foo, '双越', 100)
// console.info(f)
// console.info(f.getName())
```
# 60. Object.create 和 {} 的区别
`Object.create` 可以指定原型，创建一个空对象。<br>
`{}` 就相当于 `Object.create(Object.prototype)` ，即根据 `Object` 原型的空对象。
# 61. 写一个函数遍历 DOM 树，分别用深度优先和广度优先
```javascript
/**
 * 访问节点
 * @param n node
 */
function visitNode(n: Node) {
    if (n instanceof Comment) {
        // 注释
        console.info('Comment node ---', n.textContent)
    }
    if (n instanceof Text) {
        // 文本
        const t = n.textContent?.trim()
        if (t) {
            console.info('Text node ---', t)
        }
    }
    if (n instanceof HTMLElement) {
        // element
        console.info('Element node ---', `<${n.tagName.toLowerCase()}>`)
    }
}

/**
 * 深度优先遍历
 * @param root dom node
 */
function depthFirstTraverse1(root: Node) {
    visitNode(root)

    const childNodes = root.childNodes // .childNodes 和 .children 不一样
    if (childNodes.length) {
        childNodes.forEach(child => {
            depthFirstTraverse1(child) // 递归
        })
    }
}

/**
 * 深度优先遍历
 * @param root dom node
 */
 function depthFirstTraverse2(root: Node) {
     const stack: Node[] = []

     // 根节点压栈
     stack.push(root)

     while (stack.length > 0) {
         const curNode = stack.pop() // 出栈
         if (curNode == null) break

         visitNode(curNode)

         // 子节点压栈
         const childNodes = curNode.childNodes
         if (childNodes.length > 0) {
             // reverse 反顺序压栈
             Array.from(childNodes).reverse().forEach(child => stack.push(child))
         }
     }
 }

/**
 * 广度优先遍历
 * @param root dom node
 */
function breadthFirstTraverse(root: Node) {
    const queue: Node[] = [] // 数组 vs 链表

    // 根节点入队列
    queue.unshift(root)

    while (queue.length > 0) {
        const curNode = queue.pop()
        if (curNode == null) break

        visitNode(curNode)

        // 子节点入队
        const childNodes = curNode.childNodes
        if (childNodes.length) {
            childNodes.forEach(child => queue.unshift(child))
        }
    }
}

const box = document.getElementById('box')
if (box == null) throw new Error('box is null')
depthFirstTraverse2(box)

```
# 62. 手写 LazyMan ，实现 `sleep` 和 `eat` 两个方法，支持链式调用。
```js
class LazyMan {
    private name: string
    private tasks: Function[] = [] // 任务列表

    constructor(name: string) {
        this.name = name

        setTimeout(() => {
            this.next()
        })
    }

    private next() {
        const task = this.tasks.shift() // 取出当前 tasks 的第一个任务
        if (task) task()
    }

    eat(food: string) {
        const task = () => {
            console.info(`${this.name} eat ${food}`)
            this.next() // 立刻执行下一个任务
        }
        this.tasks.push(task)

        return this // 链式调用
    }

    sleep(seconds: number) {
        const task = () => {
            console.info(`${this.name} 开始睡觉`)
            setTimeout(() => {
                console.info(`${this.name} 已经睡完了 ${seconds}s，开始执行下一个任务`)
                this.next() // xx 秒之后再执行下一个任务
            }, seconds * 1000)
        }
        this.tasks.push(task)

        return this // 链式调用
    }
}

const me = new LazyMan('双越')
me.eat('苹果').eat('香蕉').sleep(2).eat('葡萄').eat('西瓜').sleep(2).eat('橘子')

```
# 63. 写一个 `curry` 函数，可以把其他函数转为 curry 函数
```js
export function curry(fn: Function) {
    const fnArgsLength = fn.length // 传入函数的参数长度
    let args: any[] = []

    // ts 中，独立的函数，this 需要声明类型
    function calc(this: any, ...newArgs: any[]) {
        // 积累参数
        args = [
            ...args,
            ...newArgs
        ]
        if (args.length < fnArgsLength) {
            // 参数不够，返回函数
            return calc
        } else {
            // 参数够了，返回执行结果
            return fn.apply(this, args.slice(0, fnArgsLength))
        }
    }

    return calc
}

// function add(a: number, b: number, c: number): number {
//     return a + b + c
// }
// // add(10, 20, 30) // 60

// const curryAdd = curry(add)
// const res = curryAdd(10)(20)(30) // 60
// console.info(res)
```
# 64. instanceof 的原理是什么，请用代码来表示
```js
/**
 * 自定义 instanceof
 * @param instance instance
 * @param origin class or function
 */
export function myInstanceof(instance: any, origin: any): boolean {
    if (instance == null) return false // null undefined

    const type = typeof instance
    if (type !== 'object' && type !== 'function') {
        // 值类型
        return false
    }

    let tempInstance = instance // 为了防止修改 instance
    while (tempInstance) {
        if (tempInstance.__proto__ === origin.prototype) {
            return true // 配上了
        }
        // 未匹配
        tempInstance = tempInstance.__proto__ // 顺着原型链，往上找
    }

    return false
}

// // 功能测试
// console.info( myInstanceof({}, Object) )
// console.info( myInstanceof([], Object) )
// console.info( myInstanceof([], Array) )
// console.info( myInstanceof({}, Array) )
// console.info( myInstanceof('abc', String) )

```
# 65. 请手写实现函数 bind
```js
Function.prototype.customBind = function (context: any, ...bindArgs: any[]) {
    // context 是 bind 传入的 this
    // bindArgs 是 bind 传入的各个参数

    const self = this // 当前的函数本身

    return function (...args: any[]) {
        // 拼接参数
        const newArgs = bindArgs.concat(args)
        return self.apply(context, newArgs)
    }
}

// // 功能测试
// function fn(this: any, a: any, b: any, c: any) {
//     console.info(this, a, b, c)
// }
// // @ts-ignore
// const fn1 = fn.customBind({x: 100}, 10)
// fn1(20, 30)
```
# 66. 请手写 EventBus 自定义事件，实现 `no` `once` `emit` 和 `off`
```js
export default class EventBus {
    /**
     * {
     *    'key1': [
     *        { fn: fn1, isOnce: false },
     *        { fn: fn2, isOnce: false },
     *        { fn: fn3, isOnce: true },
     *    ]
     *    'key2': [] // 有序
     *    'key3': []
     * }
     */
    private events: {
        [key: string]: Array<{fn: Function; isOnce: boolean}>
    }

    constructor() {
        this.events = {}
    }

    on(type: string, fn: Function, isOnce: boolean = false) {
        const events = this.events
        if (events[type] == null) {
            events[type] = [] // 初始化 key 的 fn 数组
        }
        events[type].push({ fn, isOnce })
    }

    once(type: string, fn: Function) {
        this.on(type, fn, true)
    }

    off(type: string, fn?: Function) {
        if (!fn) {
            // 解绑所有 type 的函数
            this.events[type] = []
        } else {
            // 解绑单个 fn
            const fnList = this.events[type]
            if (fnList) {
                this.events[type] = fnList.filter(item => item.fn !== fn)
            }
        }
    }

    emit(type: string, ...args: any[]) {
        const fnList = this.events[type]
        if (fnList == null) return

        // 注意
        this.events[type] = fnList.filter(item => {
            const { fn, isOnce } = item
            fn(...args)

            // once 执行一次就要被过滤掉
            if (!isOnce) return true
            return false
        })
    }
}

// const e = new EventBus()

// function fn1(a: any, b: any) { console.log('fn1', a, b) }
// function fn2(a: any, b: any) { console.log('fn2', a, b) }
// function fn3(a: any, b: any) { console.log('fn3', a, b) }

// e.on('key1', fn1)
// e.on('key1', fn2)
// e.once('key1', fn3)
// e.on('xxxxxx', fn3)

// e.emit('key1', 10, 20) // 触发 fn1 fn2 fn3

// e.off('key1', fn1)

// e.emit('key1', 100, 200) // 触发 fn2

```
# 67. 手写函数 call 和 apply
```js
// @ts-ignore
Function.prototype.customCall = function (context: any, ...args: any[]) {
    if (context == null) context = globalThis
    if (typeof context !== 'object') context = new Object(context) // 值类型，变为对象

    const fnKey = Symbol() // 不会出现属性名称的覆盖
    context[fnKey] = this // this 就是当前的函数

    const res = context[fnKey](...args) // 绑定了 this

    delete context[fnKey] // 清理掉 fn ，防止污染

    return res
}

// @ts-ignore
Function.prototype.customApply = function (context: any, args: any[] = []) {
    if (context == null) context = globalThis
    if (typeof context !== 'object') context = new Object(context) // 值类型，变为对象

    const fnKey = Symbol() // 不会出现属性名称的覆盖
    context[fnKey] = this // this 就是当前的函数

    const res = context[fnKey](...args) // 绑定了 this

    delete context[fnKey] // 清理掉 fn ，防止污染

    return res
}

function fn(this: any, a: any, b: any, c: any) {
    console.info(this, a, b, c)
}
// // @ts-ignore
// fn.customCall({x: 100}, 10, 20, 30)
// @ts-ignore
// fn.customApply({x: 200}, [100, 200, 300])

```
# 68. EventBus 里的数组可以换成 Set 吗？
数组和 Set 比较 （除了语法 API）
- 数组，有序结构，查找、中间插入、中间删除比较慢
- Set 不可排序的，插入和删除都很快
答案：不可以，Set 是不可排序的，如再增加一些“权重”之类的需求，将不好实现。
# 69. 用 JS 实现一个 LRU 缓存
```js
export default class LRUCache {
    private length: number
    private data: Map<any, any> = new Map()

    constructor(length: number) {
        if (length < 1) throw new Error('invalid length')
        this.length = length
    }

    set(key: any, value: any) {
        const data = this.data

        if (data.has(key)) {
            data.delete(key)
        }
        data.set(key, value)

        if (data.size > this.length) {
            // 如果超出了容量，则删除 Map 最老的元素
            const delKey = data.keys().next().value
            data.delete(delKey)
        }
    }

    get(key: any): any {
        const data = this.data

        if (!data.has(key)) return null

        const value = data.get(key)

        data.delete(key)
        data.set(key, value)

        return value
    }
}

// const lruCache = new LRUCache(2)
// lruCache.set(1, 1) // {1=1}
// lruCache.set(2, 2) // {1=1, 2=2}
// console.info(lruCache.get(1)) // 1 {2=2, 1=1}
// lruCache.set(3, 3) // {1=1, 3=3}
// console.info(lruCache.get(2)) // null
// lruCache.set(4, 4) // {3=3, 4=4}
// console.info(lruCache.get(1)) // null
// console.info(lruCache.get(3)) // 3 {4=4, 3=3}
// console.info(lruCache.get(4)) // 4 {3=3, 4=4}

```
# 70. 不用 Map 如何实现 LRU cache ？
```js
interface IListNode {
    value: any
    key: string // 存储 key ，方便删除（否则删除时就需要遍历 this.data )
    prev?: IListNode
    next?: IListNode
}

export default class LRUCache {
    private length: number
    private data: { [key: string]: IListNode } = {}
    private dataLength: number = 0
    private listHead: IListNode | null = null
    private listTail: IListNode | null = null

    constructor(length: number) {
        if (length < 1) throw new Error('invalid length')
        this.length = length
    }

    private moveToTail(curNode: IListNode) {
        const tail = this.listTail
        if (tail === curNode) return

        // -------------- 1. 让 prevNode nextNode 断绝与 curNode 的关系 --------------
        const prevNode = curNode.prev
        const nextNode = curNode.next
        if (prevNode) {
            if (nextNode) {
                prevNode.next = nextNode
            } else {
                delete prevNode.next
            }
        }
        if (nextNode) {
            if (prevNode) {
                nextNode.prev = prevNode
            } else {
                delete nextNode.prev
            }

            if (this.listHead === curNode) this.listHead = nextNode
        }

        // -------------- 2. 让 curNode 断绝与 prevNode nextNode 的关系 --------------
        delete curNode.prev
        delete curNode.next

        // -------------- 3. 在 list 末尾重新建立 curNode 的新关系 --------------
        if (tail) {
            tail.next = curNode
            curNode.prev = tail
        }
        this.listTail = curNode
    }

    private tryClean() {
        while (this.dataLength > this.length) {
            const head = this.listHead
            if (head == null) throw new Error('head is null')
            const headNext = head.next
            if (headNext == null) throw new Error('headNext is null')

            // 1. 断绝 head 和 next 的关系
            delete headNext.prev
            delete head.next

            // 2. 重新赋值 listHead
            this.listHead = headNext

            // 3. 清理 data ，重新计数
            delete this.data[head.key]
            this.dataLength = this.dataLength - 1
        }
    }

    get(key: string): any {
        const data = this.data
        const curNode = data[key]

        if (curNode == null) return null

        if (this.listTail === curNode) {
            // 本身在末尾（最新鲜的位置），直接返回 value
            return curNode.value
        }

        // curNode 移动到末尾
        this.moveToTail(curNode)

        return curNode.value
    }

    set(key: string, value: any) {
        const data = this.data
        const curNode = data[key]

        if (curNode == null) {
            // 新增数据
            const newNode: IListNode = { key, value }
            // 移动到末尾
            this.moveToTail(newNode)

            data[key] = newNode
            this.dataLength++

            if (this.dataLength === 1) this.listHead = newNode
        } else {
            // 修改现有数据
            curNode.value = value
            // 移动到末尾
            this.moveToTail(curNode)
        }

        // 尝试清理长度
        this.tryClean()
    }
}

// const lruCache = new LRUCache(2)
// lruCache.set('1', 1) // {1=1}
// lruCache.set('2', 2) // {1=1, 2=2}
// console.info(lruCache.get('1')) // 1 {2=2, 1=1}
// lruCache.set('3', 3) // {1=1, 3=3}
// console.info(lruCache.get('2')) // null
// lruCache.set('4', 4) // {3=3, 4=4}
// console.info(lruCache.get('1')) // null
// console.info(lruCache.get('3')) // 3 {4=4, 3=3}
// console.info(lruCache.get('4')) // 4 {3=3, 4=4}

```
# 71. 手写 JS 深拷贝
```js
// /**
//  * 深拷贝 - 只考虑了简单的数组、对象
//  * @param obj obj
//  */
// function cloneDeep(obj: any) {
//     if (typeof obj !== 'object' || obj == null ) return obj

//     let result: any
//     if (obj instanceof Array) {
//         result = []
//     } else {
//         result = {}
//     }

//     for (let key in obj) {
//         if (obj.hasOwnProperty(key)) {            
//             result[key] = cloneDeep(obj[key]) // 递归调用
//         }
//     }

//     return result
// }
// // 功能测试
// const a: any = {
//     set: new Set([10, 20, 30]),
//     map: new Map([['x', 10], ['y', 20]])
// }
// a.self = a
// console.log( cloneDeep(a) ) // 无法处理 Map Set 和循环引用

/**
 * 深拷贝
 * @param obj obj
 * @param map weakmap 为了避免循环引用
 */
export function cloneDeep(obj: any, map = new WeakMap()): any {
    if (typeof obj !== 'object' || obj == null ) return obj

    // 避免循环引用
    const objFromMap = map.get(obj)
    if (objFromMap) return objFromMap

    let target: any = {}
    map.set(obj, target)

    // Map
    if (obj instanceof Map) {
        target = new Map()
        obj.forEach((v, k) => {
            const v1 = cloneDeep(v, map)
            const k1 = cloneDeep(k, map)
            target.set(k1, v1)
        })
    }

    // Set
    if (obj instanceof Set) {
        target = new Set()
        obj.forEach(v => {
            const v1 = cloneDeep(v, map)
            target.add(v1)
        })
    }

    // Array
    if (obj instanceof Array) {
        target = obj.map(item => cloneDeep(item, map))
    }

    // Object
    for (const key in obj) {
        const val = obj[key]
        const val1 = cloneDeep(val, map)
        target[key] = val1
    }

    return target
}

// // 功能测试
// const a: any = {
//     set: new Set([10, 20, 30]),
//     map: new Map([['x', 10], ['y', 20]]),
//     info: {
//         city: '北京'
//     },
//     fn: () => { console.info(100) }
// }
// a.self = a
// console.log( cloneDeep(a) )
```
# 72. 讲以下 DOM 结构转换为 vnode 数据
```html
<div id="div1" style="border: 1px solid #ccc; padding: 10px;">
    <p>一行文字<a href="xxx.html" target="_blank">链接</a></p>
    <img src="xxx.png" alt="图片" class="image"/>
    <button click="clickHandler">点击</button>
</div>
```
```js
const vnode = {
    tag: 'div', // <div>
    data: {
        id: 'div1',
        style: {
            'border': '1px solid #ccc',
            'padding': '10px'
        }
    },
    children: [
        {
            tag: 'p', // <p>
            data: {},
            children: [
                '一行文字',
                {
                    tag: 'a', // <a>
                    data: {
                        href: 'xxx.html',
                        target: '_blank'
                    },
                    children: ['链接']
                }
            ]
        },
        {
            tag: 'img', // <img>
            data: {
                className: 'image', // 注意，这里要用 className
                src: 'xxx.png',
                alt: '图片'
            }
        },
        {
            tag: 'button', // <button>
            data: {
                events: {
                    click: clickHandler
                }
            }
            children: ['点击']
        }
    ]
}
```
# 73. 定义一个 `convert` 函数，将以下数组转换为树结构。
```js
interface IArrayItem {
    id: number
    name: string
    parentId: number
}

interface ITreeNode {
    id: number
    name: string
    children?: ITreeNode[]
}

function convert(arr: IArrayItem[]): ITreeNode | null {
    // 用于 id 和 treeNode 的映射
    const idToTreeNode: Map<number, ITreeNode> = new Map()

    let root = null

    arr.forEach(item => {
        const { id, name, parentId } = item

        // 定义 tree node 并加入 map
        const treeNode: ITreeNode = { id, name }
        idToTreeNode.set(id, treeNode)

        // 找到 parentNode 并加入到它的 children
        const parentNode = idToTreeNode.get(parentId)
        if (parentNode) {
            if (parentNode.children == null) parentNode.children = []
            parentNode.children.push(treeNode)
        }

        // 找到根节点
        if (parentId === 0) root = treeNode
    })

    return root
}

const arr = [
    { id: 1, name: '部门A', parentId: 0 }, // 0 代表顶级节点，无父节点
    { id: 2, name: '部门B', parentId: 1 },
    { id: 3, name: '部门C', parentId: 1 },
    { id: 4, name: '部门D', parentId: 2 },
    { id: 5, name: '部门E', parentId: 2 },
    { id: 6, name: '部门F', parentId: 3 },
]
const tree = convert(arr)
console.info(tree)
```
# 74. 定义一个 `convert` 函数，将以下对象转换为数组
```js
/**
 * @description tree to arr
 * @author 双越老师
 */

interface IArrayItem {
    id: number
    name: string
    parentId: number
}

interface ITreeNode {
    id: number
    name: string
    children?: ITreeNode[]
}

function convert1(root: ITreeNode): IArrayItem[] {
    // Map
    const nodeToParent: Map<ITreeNode, ITreeNode> = new Map()

    const arr: IArrayItem[] = []

    // 广度优先遍历，queue
    const queue: ITreeNode[] = []
    queue.unshift(root) // 根节点 入队

    while (queue.length > 0) {
        const curNode = queue.pop() // 出队
        if (curNode == null) break

        const { id, name, children = [] } = curNode

        // 创建数组 item 并 push
        const parentNode = nodeToParent.get(curNode)
        const parentId = parentNode?.id || 0
        const item = { id, name, parentId }
        arr.push(item)

        // 子节点入队
        children.forEach(child => {
            // 映射 parent
            nodeToParent.set(child, curNode)
            // 入队
            queue.unshift(child)
        })
    }

    return arr
}

const obj = {
    id: 1,
    name: '部门A',
    children: [
        {
            id: 2,
            name: '部门B',
            children: [
                { id: 4, name: '部门D' },
                { id: 5, name: '部门E' }
            ]
        },
        {
            id: 3,
            name: '部门C',
            children: [
                { id: 6, name: '部门F' }
            ]
        }
    ]
}
const arr1 = convert1(obj)
console.info(arr1)

```
# 75. `['1', '2', '3'].map(parseInt)` 输出什么？
`parseInt(string, radix)` 解析一个字符串并返回指定基数的**十进制**整数
- `string` 要解析的字符串
- `radix` 可选参数，数字基数（即进制），范围为 2-36

示例

```js
parseInt('11', 1) // NaN ，1 非法，不在 2-36 范围之内
parseInt('11', 2) // 3 = 1*2 + 1
parseInt('3', 2) // NaN ，2 进制中不存在 3
parseInt('11', 3) // 4 = 1*3 + 1
parseInt('11', 8) // 9 = 1*8 + 1
parseInt('9', 8) // NaN ，8 进制中不存在 9
parseInt('11', 10) // 11
parseInt('A', 16) // 10 ，超过 10 进制，个位数就是 1 2 3 4 5 6 7 8 9 A B C D ...
parseInt('F', 16) // 15
parseInt('G', 16) // NaN ，16 进制个位数最多是 F ，不存在 G
parseInt('1F', 16) // 31 = 1*16 + F
```
题目代码可以拆解为

```js
const arr = ['1', '2', '3']
const res = arr.map((s, index) => {
    console.log(`s is ${s}, index is ${index}`)
    return parseInt(s, index)
})
console.log(res)
```

分析执行过程

```js
parseInt('1', 0) // 1 ，radix === 0 按 10 进制处理
parseInt('2', 1) // NaN ，radix === 1 非法（不在 2-36 之内）
parseInt('3', 2) // NaN ，2 进制中没有 3
```
答案

```js
['1', '2', '3'].map(parseInt) // [1, NaN, NaN]
```
# 76. 以下代码，执行会输出什么？
```js
function Foo() {
    Foo.a = function() { console.log(1) }
    this.a = function() { console.log(2) }
}
Foo.prototype.a = function() { console.log(3) }
Foo.a = function() { console.log(4) }

Foo.a()
let obj = new Foo()
obj.a()
Foo.a()
// 执行输出 `4 2 1`
```
# 77. 以下代码，执行会输出什么
```js
Promise.resolve().then(() => {
    console.log(0)
    return Promise.resolve(4)
}).then((res) => {
    console.log(res)
})

Promise.resolve().then(() => {
    console.log(1)
}).then(() => {
    console.log(2)
}).then(() => {
    console.log(3)
}).then(() => {
    console.log(5)
}).then(() =>{
    console.log(6)
})
```
```js
## then 交替执行

如果有多个 fulfilled 状态的 promise 实例，同时执行 then 链式调用，then 会交替调用<br>
这是编译器的优化，防止一个 promise 持续占据事件

```js
Promise.resolve().then(() => {
    console.log(1)
}).then(() => {
    console.log(2)
}).then(() => {
    console.log(3)
}).then(() => {
    console.log(4)
})

Promise.resolve().then(() => {
    console.log(10)
}).then(() => {
    console.log(20)
}).then(() => {
    console.log(30)
}).then(() => {
    console.log(40)
})

Promise.resolve().then(() => {
    console.log(100)
}).then(() => {
    console.log(200)
}).then(() => {
    console.log(300)
}).then(() => {
    console.log(400)
})
```

## then 返回 promise 对象

当 then 返回 promise 对象时，可以认为是多出一个 promise 实例。

```js
Promise.resolve().then(() => {
    console.log(1)
    return Promise.resolve(100) // 相当于多处一个 promise 实例，如下注释的代码
}).then(res => {
    console.log(res)
}).then(() => {
    console.log(200)
}).then(() => {
    console.log(300)
}).then(() => {
    console.log(300)
})

Promise.resolve().then(() => {
    console.log(10)
}).then(() => {
    console.log(20)
}).then(() => {
    console.log(30)
}).then(() => {
    console.log(40)
})

// // 相当于新增一个 promise 实例 —— 但这个执行结果不一样，后面解释
// Promise.resolve(100).then(res => {
//     console.log(res)
// }).then(() => {
//     console.log(200)
// }).then(() => {
//     console.log(300)
// }).then(() => {
//     console.log(400)
// })
```

## “慢两拍”

then 返回 promise 实例和直接执行 `Promise.resolve()` 不一样，它需要等待两个过程
- promise 状态由 pending 变为 fulfilled
- then 函数挂载到 microTaskQueue

所以，它变现的会“慢两拍”。可以理解为

```js
Promise.resolve().then(() => {
    console.log(1)
})

Promise.resolve().then(() => {
    console.log(10)
}).then(() => {
    console.log(20)
}).then(() => {
    console.log(30)
}).then(() => {
    console.log(40)
})

Promise.resolve().then(() => {
    // 第一拍
    const p = Promise.resolve(100)
    Promise.resolve().then(() => {
        // 第二拍
        p.then(res => {
            console.log(res)
        }).then(() => {
            console.log(200)
        }).then(() => {
            console.log(300)
        }).then(() => {
            console.log(400)
        })
    })
})
## 答案

题目代码输出的结果是 `1 2 3 4 5 6`
```
# 78. 以下代码，运行会输出什么

```js
let a = { n: 1 }
let b = a
a.x = a = { n: 2 }

console.log(a.x) 	
console.log(b.x)
```

## `.` 优先级更高

```js
let a = {}
a.x = 100

// 可拆解为：
// 1. a.x = undefined // 初始化 a.x 属性
// 2. a.x = 100 // 为 x 属性赋值

```

再看下面的例子

```js
let a = { n: 1 }
a.x = a = { n: 2 }

// // 可以拆解为
// a.x = undefined
// let x = a.x // x 变量是假想的，实际执行时不会有
// x = a = { n: 2 }
```

## 答案

题目代码执行打印 `undefined` 和 `{ n: 2 }`

其实把 `a.x = a = { n: 2 }` 换成 `b.x = a = { n: 2 }` 更好理解

或者把连续赋值拆分为 `a.x = { n: 2 }; a = { n: 2 }` （优先级高的，先执行）
# 79. 执行以下代码，会输出什么
```js
// example1
let a = {}, b = '123', c = 123
a[b] = 'b'
a[c] = 'c'
console.log(a[b])

// example 2
let a = {}, b = Symbol('123'), c = Symbol('123')
a[b] = 'b'
a[c] = 'c'
console.log(a[b])

// example 3
let a = {}, b = { key:'123' }, c = { key:'456' }
a[b] = 'b'
a[c] = 'c'
console.log(a[b])
```

## 对象的 key

- 对象的键名只能是字符串和 Symbol 类型
- 其他类型的键名会被转换成字符串类型
- 对象转字符串默认会调用 `toString` 方法

```js
const obj = {}
obj[0] = 100
const x = { s: 'abc' }
obj[x] = 200
const y = Symbol()
obj[y] = 300
const z = true
obj[z] = 400

Object.keys(obj) // ['0', '[object Object]', 'true']
```
有些类数组的结构是 `{ 0: x, 1: y, 2: z, length: 3 }` ，如 `document.getElementsByTagName('div')`<br>
实际上它的 key 是 `['0', '1', '2', 'length']`
题目代码执行分别打印 `'c' 'b' 'c'`
# 80. 运行以下代码，会输出什么

```js
function changeArg(x) { x = 200 }

let num = 100
changeArg(num)
console.log('changeArg num', num)

let obj = { name: '双越' }
changeArg(obj)
console.log('changeArg obj', obj)

function changeArgProp(x) {
    x.name = '张三'
}
changeArgProp(obj)
console.log('changeArgProp obj', obj)
```

## 分析

调用函数，传递参数 —— **赋值**传递

```js
function fn(x, y) {
    // 继续操作 x y
}
const num = 100
const obj = { name: '双越' }
fn(num, obj)
```

以上代码相当于

```js
const num = 100
const obj = { name: '双越' }

let x = num
let y = obj
// 继续操作 x y
```

执行题目代码分别输出 `100  {name: '双越'}  {name: '张三'}`

# 81. 