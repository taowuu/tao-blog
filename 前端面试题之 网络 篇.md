# 1. 跨域解决方案
- 跨域: `ajax` 请求要求 协议/域名/端口 相同
- `jsonp` (JSON with Padding)
    - `script` 的无跨域限制
    - 服务端可以动态拼接数据返回
    - 前端定义回调函数 `window.callBack = function(data) {}`
    - 后端返回字符串 `callBack({name: 'tao'})`
    - 前端自动调用 `callBack`
- `cors` (Cross-Origin Resource Sharing)
    - `Access-Control-Allow-Origin: '*';`
    - `Access-Control-Allow-Credentials: true; // 接收 cookie`

# 2. TCP 三次握手和四次挥手
- 建立 `tcp` 连接确保双方都有收发数据的能力
- 通过 `http` 协议传输内容
- 三次握手
    - c 发包 s 接收 (s 知道有 c 连接
    - s 发包 c 接收 (c 知道 s 收到消息
    - c 正式发数据
- 四次挥手
    - c 发包 s 接收 (s 知道请求结束
    - s 发包 c 接收 (c 等待关闭
    - s 发包 c 接收 (c 知道可以关闭
    - c 发包 s 接收 (s 正式关闭

# 3. 跨域为何需要 `options` 请求
- `options` 请求就是对跨域请求之间的一次预检查

# 4. `jwt` (`json` `web` `token`
- 后端验证登录成功后返回 `token`
- 前端自行存储
- 以后访问后端都带上 `token`

# 5. `token` 和 `cookie` 区别
- `token` 需要自己传递 (`authorization`
- 需要自己存储
- 没有跨越限制
- 保存用户全部信息

# 6. `session` 和 `jwt` 区别
- `session` 存储在服务端可以快速封禁某用户
- 占用服务端内存
- 多进程不好同步 (`redis`
- 有跨越限制
- `jwt` 不占用服务端内存, 多进程无影响, 无跨域
- 服务端密钥泄露则用户信息全部丢失
- 体积大于 `cookie`

# 7. `SSO` 单点登录
- 设置 `cookie` `domain=主域名`
- 登录校验都转发到 `sso` 负责
- `oauth` 由第三方下发 `token` 并且去第三方认证

# 8. `HTTP` 和 `UDP` 区别
- `http` 应用层, `tcp` `udp` 传输层
- `tcp` 有连接有断开, 稳定传输
- `udp` 无连接无断开, 不稳定但效率高

# 9. `HTTP` 1.0 和 1.1 和 2.0 区别
- 1.0 支持基本的 `get` `post`
- 1.1 支持缓存策略, 长连接, 断点续传 `206`, 支持 `put` `delete` 用于 `restful` `api`
- 2.0 压缩 header, 服务端推送, 多路复用 (一次连接多个并行请求

# 10. `HTTPS` 中间人攻击
- 中间人伪造公钥给客户端
- 通过自己的私钥解密拿到客户端和服务端通信的密钥
- 解决: 
    - 服务端使用正规的证书响应请求
    - 对网站下发的公钥进行哈希校验

# 11. `WebSocket` 和 `HTTP` 区别
- `ws` 可以双端通信
- 没有跨越限制

# 12. `WebSocket` 和 `HTTP` 长轮询的区别
- `http` 需要等待服务端返回才能再次请
- `ws` 可以双方任意发送
