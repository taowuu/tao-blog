# 1. 深拷贝
```js
const deepColne = obj => {
    // 你的代码
    // 
    // 递归拷贝
    // 终止条件
    if(typeof obj !== 'object' || obj === null) {
        return obj
    }
    // 初始化结果
    let res
    if(obj instanceof Array) {
        res = []
    } else {
        res = {}
    }
    // 遍历保存属性值
    for(let key in obj) {
        // 保证 key 不是原型上的属性
        if(obj.hasOwnProperty(key)) {
            res[key] = deepColne(obj[key])
        }
    }
    // 返回结果
    return res
}

const tao1 = {
    name: 'tao1',
    age: 20,
    addr: {
        city: 'sz'
    },
    skill: ['js', 'vue', 'node'],
}

const tao2 = deepColne(tao1)

tao2.name = 'tao2'
tao2.age = 30
tao2.addr.city = 'jp'
tao2.skill = ['cn', 'eng', 'jp']

console.log('tao1: ', tao1)
console.log('tao2: ', tao2)

// tao1:  {
//   name: 'tao1',
//   age: 20,
//   addr: { city: 'sz' },
//   skill: [ 'js', 'vue', 'node' ]
// }
// tao2:  {
//   name: 'tao2',
//   age: 30,
//   addr: { city: 'jp' },
//   skill: [ 'cn', 'eng', 'jp' ]
// }

```

# 2. bind
```js
Function.prototype.myBind = function() {
    // 你的代码
    // 
    // 将参数拆解为数组
    const args = Array.prototype.slice.call(arguments)
    // 取出要绑定的 this
    const _this = args.shift()
    // 取出原 this
    const self = this
    // 返回一个函数
    return function() {
        self.apply(_this, args)
    }
}

const tao1 = {
    name: 'tao1',
}
const tao2 = {
    name: 'tao2',
}

const f1 = function(a, b, c) {
    console.log('this: ', this)
    console.log(a, b, c)
}
const f2 = f1.myBind(tao2, 4, 5, 6)

f1(1, 2, 3) 
// this: global
// 1 2 3
f2() 
// this:  { name: 'tao2' }
// 4 5 6
```

# 3. 事件代理
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>test</title>
</head>
<body>
    <div>
        <span>1</span>
        <button>2</button>
    </div>
</body>
<script>
const bindEvent = (elem, type, selector, fn) => {
    if (fn == null) {
        fn = selector
        selector = null
    }
    elem.addEventListener(type, event => {
        const target = event.target
        if (selector) {
            // 代理绑定
            if (target.matches(selector)) {
                fn.call(target, event)
                // fn(event)
            }
        } else {
            // 普通绑定
            fn.call(target, event)
            // fn(event)
        }
    })
}

// 普通绑定
const div = document.querySelector('div')
bindEvent(div, 'click', function (event) {
    console.log(event.target)
    // 可代理两个元素
    // span button
})

// 代理绑定
// const div = document.querySelector('div')
// bindEvent(div, 'click', 'button', function (event) {
//     console.log(event.target)
//     // 只代理 button
//     // button
// })

</script>
</html>

```

# 4. ajax
```js
const ajaxXHR = (method, url) => {
    // 你的代码
    // 
    // 0 未调用 send
    // 1 已经调用 send 正在发送请求
    // 2 send 完成已经接收到全部响应
    // 3 正在解析响应
    // 4 响应解析完成
    const xhr = new XMLHttpRequest()
    xhr.open(method, url, true)
    xhr.onreadystatechange = () => {
        if(xhr.readyState === 4) {
            if(xhr.status === 200) {
                console.log(xhr)
            }
        }
    }
}

const ajaxFetch = url => {
    // 你的代码
    // 
    // 需要设置才能使用 cookie
    // 错误状态码不会 reject
    return fetch(url).then(res => console.log(res))
}

ajaxXHR('GET', 'https://cdn2.thecatapi.com/images/ebv.jpg')
ajaxFetch('https://cdn2.thecatapi.com/images/ebv.jpg')

```

# 5. 防抖
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>test</title>
</head>
<body>
    <input>
</body>
<script>
const debounce = (fn) => {
    // 你的代码
    // 防抖 -> 等你消停了再执行
    // 高频输入只执行一次
    // 
    let timer = null
    return function() {
        if(timer) {
            clearTimeout(timer)
        }
        timer = setTimeout(() => {
            fn()
            // 保证只执行一次
            timer = null
        }, 1000)
    }
}

const input = document.querySelector('input')

input.addEventListener('keyup', debounce(function() {
    console.log(input.value)
}))

</script>
</html>
```

# 6. 节流
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>test</title>
</head>
<body>
    <input>
</body>
<script>
const throttle = (fn) => {
    // 你的代码
    // 节流 -> 按规定频率来执行
    // 一秒触发一次
    // 
    let timer = null
    return function() {
        if(timer) {
            return
        }
        timer = setTimeout(() => {
            fn()
            // 保证只执行一次
            timer = null
        }, 1000)
    }
}

const input = document.querySelector('input')

input.addEventListener('keyup', throttle(function() {
    console.log(input.value)
}))

</script>
</html>
```

# 7. 
