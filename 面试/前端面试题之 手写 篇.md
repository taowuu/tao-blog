# 1. 深拷贝
```js
const deepColne = obj => {
    // 你的代码
    // 
    // 递归拷贝
    // 终止条件
    if(typeof obj !== 'object' || obj === null) {
        return obj
    }
    // 初始化结果
    let res
    if(obj instanceof Array) {
        res = []
    } else {
        res = {}
    }
    // 遍历保存属性值
    for(let key in obj) {
        // 保证 key 不是原型上的属性
        if(obj.hasOwnProperty(key)) {
            res[key] = deepColne(obj[key])
        }
    }
    // 返回结果
    return res
}

const tao1 = {
    name: 'tao1',
    age: 20,
    addr: {
        city: 'sz'
    },
    skill: ['js', 'vue', 'node'],
}

const tao2 = deepColne(tao1)

tao2.name = 'tao2'
tao2.age = 30
tao2.addr.city = 'jp'
tao2.skill = ['cn', 'eng', 'jp']

console.log('tao1: ', tao1)
console.log('tao2: ', tao2)

// tao1:  {
//   name: 'tao1',
//   age: 20,
//   addr: { city: 'sz' },
//   skill: [ 'js', 'vue', 'node' ]
// }
// tao2:  {
//   name: 'tao2',
//   age: 30,
//   addr: { city: 'jp' },
//   skill: [ 'cn', 'eng', 'jp' ]
// }
```

# 2. bind
```js
Function.prototype.myBind = function() {
    // 你的代码
    // 
    // 将参数拆解为数组
    const args = Array.prototype.slice.call(arguments)
    // 取出要绑定的 this
    const _this = args.shift()
    // 取出原 this
    const self = this
    // 返回一个函数
    return function() {
        self.apply(_this, args)
    }
}

const tao1 = {
    name: 'tao1',
}
const tao2 = {
    name: 'tao2',
}

const f1 = function(a, b, c) {
    console.log('this: ', this)
    console.log(a, b, c)
}
const f2 = f1.myBind(tao2, 4, 5, 6)

f1(1, 2, 3) 
// this: global
// 1 2 3
f2() 
// this:  { name: 'tao2' }
// 4 5 6
```

# 3. 事件代理
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>test</title>
</head>
<body>
    <div>
        <span>1</span>
        <button>2</button>
    </div>
</body>
<script>
const bindEvent = (elem, type, selector, fn) => {
    if (fn == null) {
        fn = selector
        selector = null
    }
    elem.addEventListener(type, event => {
        const target = event.target
        if (selector) {
            // 代理绑定
            if (target.matches(selector)) {
                fn.call(target, event)
                // fn(event)
            }
        } else {
            // 普通绑定
            fn.call(target, event)
            // fn(event)
        }
    })
}

// 普通绑定
const div = document.querySelector('div')
bindEvent(div, 'click', function (event) {
    console.log(event.target)
    // 可代理两个元素
    // span button
})

// 代理绑定
// const div = document.querySelector('div')
// bindEvent(div, 'click', 'button', function (event) {
//     console.log(event.target)
//     // 只代理 button
//     // button
// })
</script>
</html>
```

# 4. ajax
```js
const ajaxXHR = (method, url) => {
    // 你的代码
    // 
    // 0 未调用 send
    // 1 已经调用 send 正在发送请求
    // 2 send 完成已经接收到全部响应
    // 3 正在解析响应
    // 4 响应解析完成
    const xhr = new XMLHttpRequest()
    xhr.open(method, url, true)
    xhr.onreadystatechange = () => {
        if(xhr.readyState === 4) {
            if(xhr.status === 200) {
                console.log(xhr)
            }
        }
    }
}

const ajaxFetch = url => {
    // 你的代码
    // 
    // 需要设置才能使用 cookie
    // 错误状态码不会 reject
    return fetch(url).then(res => console.log(res))
}

ajaxXHR('GET', 'https://cdn2.thecatapi.com/images/ebv.jpg')
ajaxFetch('https://cdn2.thecatapi.com/images/ebv.jpg')
```

# 5. 防抖
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>test</title>
</head>
<body>
    <input>
</body>
<script>
const debounce = (fn) => {
    // 你的代码
    // 防抖 -> 等你消停了再执行
    // 高频输入只执行一次
    // 
    let timer = null
    return function() {
        if(timer) {
            clearTimeout(timer)
        }
        timer = setTimeout(() => {
            fn()
            // 保证只执行一次
            timer = null
        }, 1000)
    }
}

const input = document.querySelector('input')
input.addEventListener('keyup', debounce(function() {
    console.log(input.value)
}))
</script>
</html>
```

# 6. 节流
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>test</title>
</head>
<body>
    <input>
</body>
<script>
const throttle = (fn) => {
    // 你的代码
    // 节流 -> 按规定频率来执行
    // 一秒触发一次
    // 
    let timer = null
    return function() {
        if(timer) {
            return
        }
        timer = setTimeout(() => {
            fn()
            // 保证只执行一次
            timer = null
        }, 1000)
    }
}

const input = document.querySelector('input')
input.addEventListener('keyup', throttle(function() {
    console.log(input.value)
}))
</script>
</html>
```


# 8. `url` 参数转化为对象
```js
const queryToObj = () => {
    const res = {}
    const pList = new URLSearchParams(location.search)
    pList.forEach((val, key) => {
        res[key] = val
    })
    return res
}
// https://cn.bing.com/search?q=js&qs=n&form=QBRE&sp=-1&pq=js&sc=10-2&sk=&cvid=D67659431B10432D8D38207A4EF88565&ghsh=0&ghacc=0&ghpl=
console.log(queryToObj()) 
// {q: "js", qs: "n", form: "QBRE", sp: "-1", pq: "js", …}
```

# 9. `trim`
```js
const trim = s => {
    return s.replace(/^\s+/, '').replace(/\s+$/, '')
}

console.log(trim('  j s  ')) 
// j s
```

# 10. `isEqual`
```js
const isObject = (obj) => {
    return typeof obj === 'object' && obj !== null
}

const isEqual = (obj1, obj2) => {
    // 你的代码
    // 
    // 递归
    // 终止条件
    if (!isObject(obj1) || !isObject(obj2)) {
        // 值类型
        return obj1 === obj2
    }
    if (obj1 === obj2) {
        return true
    }
    // 先判断 key
    const obj1Keys = Object.keys(obj1)
    const obj2Keys = Object.keys(obj2)
    if (obj1Keys.length !== obj2Keys.length) {
        return false
    }
    // 再判断值
    for (let key in obj1) {
        const res = isEqual(obj1[key], obj2[key])
        if (!res) {
            return false
        }
    }
    return true
}

const obj1 = {
    a: 100,
    b: {
        x: 100,
        y: 200
    }
}
const obj2 = {
    a: 100,
    b: {
        x: 100,
        y: 200
    }
}
console.log( obj1 === obj2 )
// false
console.log(isEqual(obj1, obj2))
// true
```

```

# 12. `apply`
```js
Function.prototype.myApply = function(context, args) {
    // 你的代码
    // 不会出现属性名称的覆盖
    const fnKey = Symbol()
    // this 就是当前的函数
    context[fnKey] = this
    // 绑定了 this
    const res = context[fnKey](...args) 
    delete context[fnKey] 

    return res
}

const tao1 = {
    name: 'tao1',
}
const tao2 = {
    name: 'tao2',
}

const f1 = function(a, b, c) {
    console.log('this: ', this)
    console.log(a, b, c)
}

f1(1, 2, 3) 
// this: global
// 1 2 3
f1.myApply(tao2, [4, 5, 6])
// this:  { name: 'tao2', [Symbol()]: [Function: f1] }
// 4 5 6
```

# 13. `call`
```js
Function.prototype.myCall = function(context, ...args) {
    // 你的代码
    // 不会出现属性名称的覆盖
    const fnKey = Symbol()
    // this 就是当前的函数
    context[fnKey] = this
    // 绑定了 this
    const res = context[fnKey](...args) 
    delete context[fnKey] 

    return res
}

const tao1 = {
    name: 'tao1',
}
const tao2 = {
    name: 'tao2',
}

const f1 = function(a, b, c) {
    console.log('this: ', this)
    console.log(a, b, c)
}

f1(1, 2, 3) 
// this: global
// 1 2 3
f1.myCall(tao2, 4, 5, 6)
// this:  { name: 'tao2', [Symbol()]: [Function: f1] }
// 4 5 6
```


# 15. `instanceof`
```js
const myInstanceof = (instance, origin) => {
    if (instance == null) return false 

    const type = typeof instance
    if (type !== 'object' && type !== 'function') {
        // 值类型
        return false
    }
    // 为了防止修改 instance
    let tempInstance = instance 
    while (tempInstance) {
        if (tempInstance.__proto__ === origin.prototype) {
            return true // 配上了
        }
        // 未匹配
        // 顺着原型链往上找
        tempInstance = tempInstance.__proto__ 
    }

    return false
}

console.info( myInstanceof({}, Object) )
console.info( myInstanceof([], Object) )
console.info( myInstanceof([], Array) )
console.info( myInstanceof({}, Array) )
console.info( myInstanceof('abc', String) )
console.info( myInstanceof('abc', Object) )
```
